## 标识列（自增）

* 又称自增长列，

* 可以不用手动插入值，系统提供默认的序列值

    ```mysql
    1.标识列不一定必须要跟主键搭配，但是必须是一个key
    2.一个表中只能有一个标识列
    3.标识列的类型只能是数值型
    4.查看标识列：
      show variables like '%auto_increment%'
      设置步长：
      set auto_increment_increment=3
      也可以通过手动插入值，设置起始值
    
    #1.创建表时设置
    create table if exists 表名(
    	列名 类型 auto_increment)#id int unique auto_increment
    	
    #2.修改表时设置
    alter table 表名 modify column 列名 列数据类型（int） [约束类型] auto_increment
    
    #3.删除标识列（修改时）
    直接把修改表时设置标识列里面的auto_increment去掉，然后刷新就行
    
    ```

## 事务

### 概念

*   一个或一组sql语句组成一个执行单元，每个mysql语句相互依赖，这个执行单元要么全部执行，要么全部不执行。即单个语句出现意外整个单元都会回滚（撤销），所有被影响的数据将返回事务开始以前的状态
*   innodb支持事务

### acid属性

* 原子性（atomicity）

    原子性是事务不可分割的工作单位，事务中的操作要么都发生，要么都不发生

* 一致性(comsistency)

    事务必须使数据库从一个一致性状态转换到另一个一致性状态

* 隔离性(isolation)

    事务的隔离性是指一个事务的执行不能被其他事务干扰，即使一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能相互干扰。	

* 持久性(durability)

    是指一个事务一旦被提交，它对于数据库中数据的改变就是永久的，接下来的其他操作和数据库故障不应该对其有任何影响

    | 原子性 | 一个事务不可再被分隔，要么都执行，要么都不执行       |
    | ------ | ---------------------------------------------------- |
    | 一致性 | 事务必须使数据从一个一致性状态转换到另一个一致性状态 |
    | 隔离性 | 一个事务的执行不受其他事务的影响                     |
    | 持久性 | 一个事务一旦被提交，则会永久改变数据库的数据         |

### 分类

*   隐式（自动）事务：事务没有明显的开启和结束标记

    *   比如：insert 、update 、delete语句

* 显示事务：事务有明显的开启和结束标记

    *   前提：必须先禁用自动提交功能

    *   设置：set autocommit=0（只对当前事务有作用，每次打开就要重新设置）

### 使用

```mysql
# 1.开启事务
    set autocommit =0  #禁用自动提交
    start transaction; #开启事务，可以省略
    #2.编写事务中的sql语句(即需要整体执行的语句)
    （select、insert、update、delete）#基本只支持这四个，其实select有没有都可以，没影响查看	
    语句1
    语句2
    ...
    语句3
#2.设置回滚点
    savepoint 回滚点名称
#3.结束事务
    commit;#提交事务，
    rollback;#回滚事务，结束事务之前存在内存中
        rollback to 回滚点名称 #回滚到指定的地方
```

### 并发事务

*   事务并发问题发生原因

    *  多个事务  同时操作 同一个数据库 数据，当这些事务访问数据库中相同的数据时，如果不采取必要的隔离机制，就会导致各种并发问题

*   并发问题

    *   脏读：	
        *   T1读取了已经被T2更新单还没有被提交的字段之后，若T2回滚，T1读取的内容就是临时无效的
        *   （一个事务读取了其他事务没有提交的数据，读到的是其他事务“更新”的数据，针对一条数据）
      *   不可重复读：T
          *   T1读取了一个字段，然后T2更新了该字段，之后，T1再读取同一个字段，值就不同了
          *   （一个事务多次读取，结果不一样）
      *   幻读：
          *   T1从一个表中读取了一个字段，然后T2在该表中插入了一些新的行，之后，如果T1再次读取同一个表，就会多出几行。
          *   （一个事务读取其他事务还没有提交的数据，只是读到其他事务“插入”得数据，针对多条数据）
      *   注意 ：(两个事务T1、T2)

*   隔离解决

    *   事务的隔离性
        
        *   数据库必须具有隔离并发运行各个事务的能力，使得他们不会相互影响，以避免各种并发问题
        
	*   隔离级别
    	*  一个事务和其他事务隔离的程度。不同的隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但是并发性就越弱
    
        | 隔离级别          | 中文         | 描述                                                         | 出现的问题                           |
        | ----------------- | ------------ | ------------------------------------------------------------ | ------------------------------------ |
        | read unicommitted | 读未提交数据 | 允许事务读取其他事务提交的变更                               | 脏读、幻读                           |
        | read commmited    | 读已提交     | 只允许事务读取已经被其他事务提交的变更                       | 避免脏读，会出现不可重复读、幻读     |
        | repeatable read   | 可重复读     | 确保事务可以多次从一个字段中读取相同的值，在这个事务持续期间，进制其他事务对这个字段进行更新 | 可避免脏读、不可重复读，但是仍有幻读 |
    | serializable      | 串行         | 确保事务可以从一个表中读取相同的行，在这个事务持续期间，进制其他事务对该表进行插入如、更新和删除操作 | 并发问题可以被避免，但是性能是非低下 |
	
	* 数据库支持
	
	    *   Oracle 支持
	        *   read commited(默认)、serializable
	    *   mysql 
	        *   支持:四种，repeatable read(默认) 
	
	*   隔离使用
	
	    ```mysql
	    #每启动一个mysql程序，就会获得一个单独的数据库连接，每个数据库连接都有一个全局变量@@tx_isolation，表示当前事务隔离级别
	    
	    #查看当前的隔离级别
	    select @@tx_isolation
	    #设置当前mysql连接的隔离级别
	    set transaction isolation level 隔离级别；
	    #设置数据库的隔离级别
	    set session|global transaction isolation level 隔离级别
	    ```
### 事务删除

