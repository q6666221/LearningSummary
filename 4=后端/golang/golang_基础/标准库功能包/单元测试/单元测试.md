

## 需要总结

```go
// 暂时没有读懂，需要后面总结
https://wiki.jikexueyuan.com/project/go-command-tutorial/0.12.html   

对于Test fixtures，建立一个testdata目录来存放数据。
```

## 1.test测试框架

* go自带的轻量级测试框架

## 2.应用

* 实现：单元测试、性能测试、压力测试
* 确保每个函数可运行，并且运行结果正确
* 确保写出的代码性能良好
* 计时发现逻辑错误，性能测试主要是在高并发情况下还能保持稳定

## 3不适用测试代码

*   函数中写死了 MySQL 的连接方式，硬要写单元测试的话，会污染生产环境的数据库。

*   从很多外部依赖获取数据并处理，输入和结果过于复杂。

    ```go
    没法测试的代码都是不太好的代码，它们往往没有合理组织，不灵活，甚至错误百出。
    ```

    





## 5.书写规范

### 注意

*   一个测试文件对应一个被测试文件，放在同一目录（包）下
*   一个测试文件中可以含有多个测试用例
*   测试用例会按照源码中写的顺序依次进行
*   测试用例函数，并没有放在 main 函数中，也执行了

### 测试文件名

*   文件 ：  ``以 ..._test.go结尾``

### 测试函数名

#### 单元测试

```go
前缀 ： Test
后缀 ： Xxx  函数名，X 必须大写，是任何字母数字字符串（第一个字母不能是[a-z]）,用于识别测试程序
参数 ： *testing.T
示例 ： 
func TestSum(t *Testing.T){
    测试代码块
}

// 于单元测试，至少包括一个校验，可使用testify进行断言。
```



#### 性能测试

```go
前缀 ： Benchmark
后缀 ： Xxx  函数名，X 必须大写，是任何字母数字字符串（第一个字母不能是[a-z]）,用于识别测试程序
参数 ： *Testing.B
示例 ： 
func TestSum(t *Testing.B){
    测试代码块
}
```



#### 示例测试

```go
// 还没有碰到，只是看到有这个东西

前缀 ： Example
后缀 ： Xxx
参数 ： // 还没看过
```



## 6. 单元 / 功能 测试

### 介绍

*   就是测软件运行耗费多长时间
*   算法好不好：只看时间、内存开销

### 执行命令

```go
go test  
	1. 自动搜集所有的测试文件（*_test.go），提取全部测试函数
	2. 运行正确，无日志，错误时，会输出日志


参数
-v    			
	显示所有测试函数运行细节
-run regex
	regex :指定要执行的测试函数
   	go test -v -test.run TestXxx
测试文件名称 		
	运行指定文件，可以同时测多个文件
	示例 xxx_test.go  xxx.go 带上源文件，可以不带
```



### 方法

*   Fail: 标记失败，但继续执行当前测试函数
*   FailNow: 失败，立即终止当前测试函数执行
*   Log: 输出错误信息
*   Error: Fail + Log
*   Fatal: FailNow + Log
*   Skip: 跳过当前函数，通常用于未完成的测试用例



## 7.性能 / 压力 测试

### 测试函数命名

```go
// 代码
    func BenchmarkGetArea(b *testing.B) {
        
        b.Log("开始测试")
        
        // 汇报内存开销
        b.ReportAllocs()
        
        // 多次调用方法，进行轮选，求平均值时长、开销
        // b.N 是自动分配的
        for i := 0; i < b.N; i++ {    // 固定
            GetArea(40, 50)
        }
    }


// 注意结果中的
				 
BenchmarkGetArea-4  2000000000   0.35 ns/op  

自动分配的测试次数 				2000000000 
平均每次运行时间开销  		    0.35 ns/op
对象的占用  					   0 B/op
以供分配的内存的数量（对象的数量）   0 allcos/op
```



### 执行命令

```go
1. go test  默认不执行性能测试
执行性能测试	go test -bench<pattern>

// 参数
-bench=. 
	当前文件夹的测试
-count=3
	执行 3 次求平均值
-benchmem
	输出内存分配统计
-benchtime=“3s”
	指定测试时间 , 3s 能够执行多少次，最好不要和 count 同时使用
-cpu=8
	指定GOMAXPROCS
-timeout="5s"
	超时限制


-cpuprofile：cup.out
	cpu profiling 数据要保存的文件地址,指定生成的 CPU 保存的文件
	cup.out 你可以随意起，只要符合x.x 即可
-memprofile: mem.out
	memory profiling 数据要报文的文件地址,指定生成的 Memory profiling 保存的文件
	mem.out 你可以随意起，只要符合x.x 即可


```

### 结果分析

```go
$ go test -v -bench=. -cpu=8 -benchtime="3s" -timeout="5s" -benchmem
输出：
goos: darwin
goarch: amd64
Benchmark-8     5000000000           0.34 ns/op        0 B/op          0 allocs/op
PASS
ok      _/Users/golang_learning/testTB  1.766s

// ---参数分析
Benchmark-8：-cpu参数指定，-8表示8个CPU线程执行
5000000000：表示总共执行了5000000000次
0.34 ns/op：表示每次执行耗时0.34纳秒
0 B/op:表示每次执行分配的内存（字节）
0 allocs/op：表示每次执行分配了多少次对象
```

### 性能测试报告

*   参看下面的性能测试分析报告

### 压测工具

*   参看压测工具

## 3.覆盖率测试

### 介绍

*    覆盖率测试能知道测试程序总共覆盖了多少业务代码
*    也就是 demo_test.go 中测试了多少 demo.go 中的代码，可以的话最好是覆盖100%

### 执行命令

```go
加一个参数即可，可以看出进行的测试，到底有多少的覆盖率

// 覆盖率测试
	 go test -cover
```





## 测试方法

### 1.表驱动测试

#### 介绍

*   每个子用例对应一个使用场景。
*   有新的边缘情况，可以很方便地添加到测试用例。

#### 步骤

*   把需要测试的输入数据和期望结果写在一个数据表中
    *   使用 map  : key 为输入数据 ，value 为期望输出数据
    *   使用切片  ： value 设置成 map 、struct 等
*   简单迭代表中的每条记录，并执行必要的测试

#### 代码

```go
func Sum(a,b int) int {
    return a+b
}
// -编写测试 ---

func TestSum(t *testing.T){
    // map[]struct{}
    var tests = []struct{
        a_input int
        b_input int
        out int
    }{
        {1,2,3},
        {1,1,2},
        {2,2,4},
    }
    
    for i , tt := range tests {
        s := Sum(tt.a_input,tt.b_input)
        if s != tt.out {
             t.Errorf(“%d + %d => %d, wanted: %d”, tt.a_input,tt.a_input, s, tt.out)
        }
    }   
}

```



### 2. testify

*   assert  ：简化条件判断 
*   mock  ：隔离第三方依赖或者复杂调用
*   mock http request
*   stub redis
*   stub MySQL

### 4.错误进行输出


```go
// fmt.Printf(" AddUpper(10)执行错误，期望值=%v 实际值=%v\n",55,res)
	t.Fatalf(" AddUpper(10)执行错误，期望值=%v 实际值=%v\n",55,res)

// 如果正确，输出日志
	t.Logf(" AddUpper(10)执行正确...")


//注意：
2.使用Error、fail或相关方法发出失败信号
4.一个文件内所有的测试用例都会执行，遇到错误的，就会退出 
```



### 5.结果

```go
PASS  测试用例成功
FAIL  测试用例失败

t.log()
t.Errorf()
```









## 编写测试原则

1.  编写可测试的代码

    1.  编写代码的时候，需要考虑这段代码是否容易测试

    2.  在构造函数中创建对象，很难进行测试，如果对象含有某些昂贵的操作，代码也会变得不容易测试，所以改用依赖注入的方式将代码变得容易测试

        ```go
        func NewHouse() *House {
            kitchen := new(Kitchen)
            bedroom := new(Bedroom)
            return &House{
                kitchen: kitchen,
                bedroom: bedroom,
            }
        }
        //---改成---------------------------
        func NewHouse(Kitchen *k, Bedroom *b) *House {
            return &House{
                kitchen: k,
                Bedroom: b,
            }
        }
        ```

2.  在代码上主干分支以前，必须包含测试代码

3.  确保所有的测试全部通过

4.  良好的测试可以描述代码如何组织

    1.  代码可以通过测试来直接描述程序行为，
    2.  如果无法通过测试看出来其功能，需要考虑进行更细的拆分

5.  单元测试应全自动化，避免人工介入

    1.  避免使用 fmt.Print 等方式进行人肉验证
    2.  使用 *testing 对象或assert 进行验证

6.  每个对外暴露的接口和主流程都应拥有测试用例

    1.  除非函数功能特别复杂，否则大部分情况只需要关心程序对外暴露接口的测试
    
7.  对不可测得代码重构，使之变得可测

8.  每个测试用例都是一座孤岛，不能依赖其他测试用例

    1.  测试用例的执行结果不易哦你更改依赖其他测试用例，也不应依赖状态化的全局变量
    2.  他们是独立执行的，只依赖程序功能

9.  确保测试不受环境影响

    1.  对于无法使用的外部依赖（网络，DB）可以使用 Monking 来做依赖替换
    2.  避免依赖外部服务
    3.  

10.  测试应完全通过 race detection

     1.  通过 race detection 的检测，确保程序在运行 go test -race 的情况下也能通过测试

11.  测试前后，保持数据环境清理干净

     1.  在测试用例中创建的一些临时文件或记录，尽量在用例结束前清理

12.  保证足够高的覆盖率

13.  避免结果随机

14.  避免无意义重复

15.  避免断言时间的结果

16.  优雅地实行前置和后置任务

17.  测试用例之间相互隔离

18.  

## 6.示例

```go
// 测试文件，不需要 func main() 函数，但是可以设置一个功能的函数

// 只有这种情况。其他函数可以小写test ,其他都要大写
// 相同类型的才能写到一块儿，不不相同的不能写到一块儿
func TestAll(t *testing.T) {
    // 调用方法,执行测试函数
	t.Run("测试添加用户：", testSum)
    // 调用方法,执行测试函数
	t.Run("测试添加用户：", testAdd)
}

func testSum(t *testing.T){
    测试代码
}

func testAdd(t *testing.T){
    测试代码
}
```





## 参考

```go
https://www.jianshu.com/p/1adc69468b6f
https://www.cnblogs.com/nickchen121/p/11517452.html
https://zhuanlan.zhihu.com/p/55544032
```



