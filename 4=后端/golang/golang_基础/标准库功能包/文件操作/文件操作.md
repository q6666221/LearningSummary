

## 

## 文件

* 文件就是数据源，文件就是一个指针
* 文件类型 ： 指针
* file 叫 file 对象、file 指针、file 文件句柄
* 流
    * 流：数据在数据源（文件）和程序（内存）之间经历的路径
    * 输入流：数据从数据源（文件）到程序（内存）的路径 ：读文件的路径
    * 输出流：数据从程序（内存）到数据源（文件）的路径  ：写文件的路径

## 零星整理

```go
// //函数退出时，及时关闭file句柄，否则会有内存泄漏
    获取文件信息(名字，类型)		  
    打开文件  -   读取文件内容存入 []byte	  

写入文件
	文件打开 - 写入 
```

### 文件路径

```go
filePath = "D:\desk\blognew1\readme.md"
```



### 获取文件信息

```go
// 可以查询 name , size ,Mode 等 ，看 具体源码 , 进行文件判断
	file_Info := os.Stat(filepath)     


//就是使用os.Stat函数返回值进行判断的，需要自行构建函数
func  PathExists(path string)(bool,error){
    _,err := os.Stat(path)
    if err == nil{
        // 文件或者目录存在
        return true,nil
    }
    if os.IsNotExist(err){
        //判断为true,说明文件或文件夹不存在
        return false,nil
    }
    
    // 返回其他类型则不确定是否存在
    return false,err
}

```

### 打开文件

```go
// 单纯打开文件
		f := os.Open(path)  
		defer close
// 文件不存在就创建
		f := os.OpenFiel(filePath,os.O_WRITE,0666) // 修改flag，达到不同的目的，查看os包的flag
		defer close
```

### 读取文件

```go
// 读取文件，必须要文件打开

// 自定义每次读取的大小 : 注意在循环外创建 []byte
	for { 
        f.read([]byte) 
        读取退出
    }

// bufio 带缓存读取 默认缓冲区为4096
	reader := bufio.NewReader(f)
	for {
        content_string := reader.readString("\n")  // 按要求读取
        退去退出
    }
// 一次性完全读取 （小文件）
		// 文件打开和关闭都被封装到ReadFile函数中去了,不用显式的open、close
	content_[]byte := ioutil.ReadFile(filepath)

// 读取退出

if err == io.EOF {
    return 
} if err != nil {
   返回错误
}

```



### 创建

```go
f := os.OpenFiel(filePath,os.O_WRITE,0666) // 修改flag，达到不同的目的，查看os包的flag
defer f.Close()
```



### 写入文件

```go
// 要想写入文件，文件必须打开

// 换行(有些编辑器 换行是\r\n)

// 单纯写入
	writer := bufio.NewWriter( f )  
    //写入文件，上面只是创建个句柄，从字符串写入
    for i:=0; i<5; i++{
        writer.WriteString(str)  //在缓存中，没有写入文件
    }
    // 需要调用Flush方法，将缓存数据写入文件中 ，否则文件会丢失数据
    writer.Flush()

// 带创建写入
	ioutil.WriteFile(target_filepath,data,0666)	
```

### 复制

```go
//5.利用io.Copy() 将读取操作得到的数据，传递给写入操作，就完成了复制（注意返回这个）

 io.Copy(des Write,src Reader)(written int64,err error)
```

# 5.命令行参数

* 获取命令行的参数，来解析都输入了什么，

## 1.os.Args

```go
一个string切片，可以获得命令行各个参数

就是你输入命令行,运行的时候： hello.exe slun c:/hello
// 通过遍历打印os.Args 可以得到你都输入的是什么
要严格按照参数顺序写，顺序一旦变化，Args打印出来就变了
```



## 2.flag包

```go
intvar  /  

func main(){
	// 定义几个变量，用于接收命令行参数

	var user string
	var pwd string
	var host string 
	var port int

	// &user 就是接收用户命令行中输入的 -u后面的参数值
	// "u" 就是 -u 指定参数
	// ""  默认值
	// "用户名默认为空"说明
	flag.stringVar(&user,"u","","用户名默认为空")
	flag.stringVar(&pwd,"pwd","","用户名默认为空")
	flag.stringVar(&host,"h","localhost","主机名，默认为localhost")
	flag.stringVar(&port,"port",3306,"端口号，默认是3306")

	// 必须要进行转化
	flag.Parse()

	//输出结果
	fmt.Printf("user=%v pwd=%v host=%v port=%v",user,pwd,host,port)

}
```























































## 应用

*   文件复制

    ```go
    图片、电影、MP3等二进制文件
    
    源文件
    	打开 - 内容读取到 []byte --  获取到内容 str_content
    
    目的文件
    	打开（涉及新建） -  写入 str_content
    	打开（涉及新建） -  copy()
    ```

    