# 1.package regexp

* 位置：golang标准文库的 regexp 包
* 采用RE2语法，与python一致

## 概念

*   正则表达式
    *   普通字符（例如字符 a 到 z）以及特殊字符（称为"元字符"）构成的文字序列
    *   可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。



# 注意

* 区分下运算级别，是不是会好一点儿？
* 下面所指的文本也就是字符串
* 正则表达功能最强在替换（复杂的）然后是搜索
* 一下一个字符和一个子表达式，是一样的

```
[ ]  就是把多个字符定义为一个集合，有人也会把一个字符定义为一个集合，
许多正则表达式支持使用一些元字符去改变另一些元字符
--------------------------------------------------------------------------------
把匹配的情况考虑周全并写出一个匹配结果符合预期的正则表达式容易
把不需要匹配的情况也考虑周全并确保他们都将被排除在匹配结果之外往往要困难的多
---------------------------------
开发一个正则表达式拆解分析的功能
一般来说，元字符不匹配换行符
多使用非贪婪

```



# 1.元字符

```
+
```



## 1.单字符串

```
.              任意字符,除了换行符（标志s==true时还包括换行符）,当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符（任何一个单个的字符，可连续使用多个）
[xyz]          表示一组字符,单独列出,匹配到：‘x’ 'y'或‘z’
[^xyz]         x,y,z以外的字符
```

## 2.组合

```
xy             匹配x后接着匹配y
x|y            匹配x或y（优先匹配x）
```

## 重复

```
表达式 
```

## 分组/子表达式

```python
表达式 ：分组
```

## 边界匹配

```go
表达式 ：定位符
```

* * 

## 转义序列

```go
参看表达式 ：空白符
```



## 7.大小写转换

```
\E			结束\L 或 \U转换
\l			把下一个字符转为小写
\L			把 \L 到 \E 之间的字符全部转换为小写
\u			把下一个字符转为大写
\U			把 \U 到 \E 之间的字符全部转换为大写
```



## 7.字符族

```
[A-Z]            字符范围（方括号内部才可以用）
```



## 8. 预定义字符族作为字符族的元素： 



## 9.perl 字符族

```
\d             任意一个数字，等价于 [0-9]
\D             不是数字  非\d
\s             任意空白字符 == [\t\n\f\r ]
\S             非 \s
\w             任意一个字母、数字、下划线   == [0-9A-Za-z_]
\W             非 \w
```

## 10 .posix 字符类

* 就是posix 字符类
* 此类字符需要使用在方括号内，两对方括号[[:alnum:]]

```
[:alnum:]      任何一个字母、数字	== [0-9A-Za-z]
[:alpha:]      任意一个字母		  == [A-Za-z]
[:ascii:]      == [\x00-\x7F]
[:blank:]      空格或制表符		  == [\t ]
[:cntrl:]      ASCII控制字符（ASCII0到31，再加上127）== [\x00-\x1F\x7F]
[:digit:]      任意一个数字		  == [0-9]
[:print:]      打印一个可打印字符	== [ -~] == [ [:graph:]]
[:graph:]      和[:print"]一样，但是不包括空格		== [!-~] == [A-Za-z0-9!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~]
[:lower:]      任何一个小写字母		== [a-z]
[:punct:]      既不属于[:alnum:]也不属于[:cntrl:]的任何一个字符	== [!-/:-@[-`{-~]
[:space:]      任意一个空白字符，包括空格	== [\t\n\v\f\r ]
[:upper:]      任何一个大写字母== [A-Z]
[:word:]       == [0-9A-Za-z_]
[:xdigit:]     任意一个十六进制数字、字母		== [0-9A-Fa-f]
```

# 2.回溯引用

```
表达式 ：引用
```



## 1.语言实现区别

* 不同语言实现回溯引用的方法是不一样的



# 3.前后查找

```
表达式 ：子表达式
```



# 4.嵌入条件

* 并非所有的正则表达式都支持条件处理

## 1.分类

* 根据一个回溯引用来进行条件处理
* 根据一个前后查找进行条件处理

## 2.回溯引用条件

* 只在一个前面的子表达式搜索成功的情况下才允许使用的一个表达式

  ```python
  (...) (?(1)...)  // 只有前面的子表达式匹配到了，?(1)所处的表达式后面的模式才会执行，1是第一个表达式
  
  # 如果backer-reference存在，则执行true-regex，不存在执行false-regex
  # backer-reference 可以是数字表达第几个表达式，也可以是字符，表示匹配到字符的话
  ?(backer-reference)true-regex|false-regex) 
  ```

## 3.前后条件查找

* 只有在一个向前或者向后查找操作区的成功的情况下才允许一个表达式使用

  ```python
  # 其实还是   ?(backer-reference)true-regex|false-regex)
  (?(?=-)-\d{4})  //使用条件？=-匹配-(但不消费)，如果条件满足（-存在）,返回之后的内容，则-\d{4} 将那个连字符和随后的4位数字，存在则匹配，不存在则不匹配
  ```

  





