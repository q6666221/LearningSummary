## 2.创建方法 

*    只要通过net/http包调用 ListenAndServe 函数并传入网络地址以及负责处理请求的处理器( handler )作为参数即可
     *    如果网络地址参数为空字符串，服务器默认使用80端口进行网络连接；
     *    如果处理器参数为 nil，服务器将使用默认的多路复用器 DefaultServeMux， 
*    多路复用器 
     *    调用 NewServeMux 函数创建 
     *    接收到用户的请求之后根据请求的URL来判断使用哪个处理器来处理请求，找到后就会重定向到对应的处理器来处理请求。 

## 3.多路复用器

```js
router --- 监听里面有 --- 多路复用器
	route  ---   设置路由 --- 每一个处理器函数

// 路由里面都是 URL 和函数，非函数的要转化为函数
handle()    //  能将一个处理器 (带有处理器函数的结构体)  转化成一个处理器函数
handlefunc（）  // 里面就是一个处理器函数
```



### 使用默认的多路复用器

#### 1.  处理器函数

```go
// 使用处理器函数处理请求 —— 首选

// HandlerFunc  将一个带有正确签名的函数 f 转换成一个带有方法 f 的 Handler。
// 服务器响应 ， 客户端请求
func handler (w http.ResponseWrite , request *http.Requst){
    fmt.Fprintln(w,"正在通过处理器函数处理你的请求")
}

func WebHandlerFunc(){
    
    // 指定处理指定请求的处理器 handler 为向 url发送请求时，调用的函数
    // 浏览器输入 /hello ,就调用执行 handler 函数
    http.HandleFunc("/hello",handler)
    
    // 创建路由,监听路由（默认80） ，nil 使用默认的 DefaultServeMux
    err := http.ListenAndServe("8080",nil)
    if err != nil {
        fmt.Printf("http serve failed, err = %v\n  :" , err)
        return
    }
}


```

####     2. 使用处理器

```go
handle()  讲一个处理器变成一个处理器函
//使用处理器处理请求
type MyHandler struct {}

// 处理器方法，重要的就是你自己设计的方法的 servehttp 的参数，参数，参数
func (mh *MyHandler) ServeHTTP (respone http.ResponeseWrite , request *http.Request){
    fmt.Println(respone , "正在通过创建的处理器处理你的请求")
}

func WebHander(){
    myHandler := Myhandler{}

    // 这里是 handler 注意
    http.Handle("/myHandler",&myHandler)
    http.ListAndServe(":8080" , nil )
}
```



### 自定义多路复用器

#### 1.new

```go
// 创建处理器函数

func handler(w http.ResponeWriter , r *http.Request){
    fmt.Fprintln(w , "通过自己创建的多路复用器处理请求"，r.URL.Path)
}

func WebCustom(){
    
    // 创建多路复用器
    mux := http.NewServeMux()
    
    // http.HandleFunc("/mux",handler)
    mux.HandleFunc("/mux",handler)
    
    //创建路由
    // http.ListenAndServe(":8080",nil)
    http.ListenAndServe(":8080",mux)
}
```



#### 2.mux[] 配置 处理器

```go
// 创配置服务器信息

type myHandler struct{}
func (*myHandler) serverHTTP (W http.ResponseWrite , r *http.Request) {
    if h ,ok := mux[r.URL.String()]; ok {
        h(w,r)
        return
    }
}


func sayHello(W http.ResponseWrite , r *http.Request){
    fmt.Fprintln(w,"通过详细配置服务器的信息处理请求！")
}

var mux map[string]func(http.Response,*http.Request)

func mian(){
    mux := make(map[string]func(http.Response,*http.Request))
    mux["/sayhello"]=  sayHello
    
    // 创建 Server 结构，并详细配置里面的字段，标准库里面有具体含义
    server := http.Server{
        Addr : ":8080",
        Handler : &myHandler{},
        ReadTimeout : 2*time.Second
    }+
    server.ListenAndServe()
}
```



## 静态文件

*   去前缀

```js
// 作为
http.Handle("/static/",
	 http.StripPrefix("/static/",   //  第二个参数是 handler
            	http.FileServer(http.Dir("views/static"))))
```

