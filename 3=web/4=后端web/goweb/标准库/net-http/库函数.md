## 介绍

*   net/http 标准库可以分为客户端和服务端两个部分，苦衷的结构和函数有些只支持客户端和服务端中的一个，有些是同时支持两者

*   客户端

    *   client    response  
    *    Header    Request    Cookie

*   服务端

    *   Server   ServerMus Handler / HandleFunc   ResponseWriter    
    *   Header     Request   Cookie

    
    
    

## 路由

*   介绍

    ```js
    路由原理和路由器原理相同，我就简单概述下：不同的请求地址会交给路由处理来转发给相应的控制器处理，所以说路由就可以在转发前修改转发地址，你可以在这上面大作文章。
    
    
    为什么要使用路由？      传统web开发是每一个请求地址都会请求服务器来进行处理，但是用户有些操作则无需请求服务器，直接页面端修改下逻辑就能达到目的，这种最好使用路由，也许题主会有疑问：直接使用js处理下不就行了。使用js直接处理这些是可以的，事实上以前我们也这么做，但是这样做不便于用户收藏当前页，因为使用js时并不更新url，但是使用路由时，url也是随着改变的，用户浏览到一个网页时可以直接复制或收藏当前页的url给别人，这种方式对于搜索引擎和用户来说都是友好的。
    
    
    解析URL，调用对应的控制器（的方法，并传递参数）
    
    客户端的请求是以URL的形式传递给服务器的。传统WEB开发中，URL对应服务器上某个目录下的某个文件。MVC开发则改变了这种对应关系，WEB 服务器会截获所有请求，不做资源存在性检查，直接转发给网站的路由程序。路由器再调用相关的控制器。控制器调用相关的服务，并返回视图对象。路由器再从视图对象中提取生成好的网页代码返回给Web服务器，最终返回给客户端。
    
    “route”是指根据url分配到对应的处理程序
    
    路由的作用就是解析URL，调用对应的控制器（的方法，并传递参数）。客户端的请求是以URL的形式传递给服务器的。传统WEB开发中，URL对应服务器上某个目录下的某个文件。MVC开发则改变了这种对应关系，WEB 服务器会截获所有请求，不做资源存在性检查，直接转发给网站的路由程序。路由器再调用相关的控制器。控制器调用相关的服务，并返回视图对象。路由器再从视图对象中提取生成好的网页代码返回给Web服务器，最终返回给客户端
    
    
    路由器里根据目标IP，找到中间需要经过的路由器路径。
    Web里根据网址找到能处理这个URL的程序或模块。
    
    路由的概念来源于服务端，在服务端中路由描述的是 URL 与处理函数之间的映射关系
    
    在 Web 前端单页应用 SPA(Single Page Application)中，路由描述的是 URL 与 UI 之间的映射关系，这种映射是单向的，即 URL 变化引起 UI 更新（无需刷新页面）。
    
    路由就是URL到函数的映射。
    
     router 可以理解为一个容器，或者说一种机制，它管理了一组 route。简单来说，route 只是进行了URL和函数的映射，而在当接收到一个URL之后，去路由映射表中查找相应的函数，这个过程是由 router 来处理的。一句话概括就是 "The router routes you to a route"。
     
     于服务器来说，当接收到客户端发来的HTTP请求，会根据请求的URL，来找到相应的映射函数，然后执行该函数，并将函数的返回值发送给客户端。对于最简单的静态资源服务器，可以认为，所有URL的映射函数就是一个文件读取操作。对于动态资源，映射函数可能是一个数据库读取操作，也可能是进行一些数据的处理，等等。
     
     
     客户端（通常为浏览器）来说，路由的映射函数通常是进行一些DOM的显示和隐藏操作。这样，当访问不同的路径的时候，会显示不同的页面组件。客户端路由最常见的有以下两种实现方案：
    
        基于Hash基于History API
        
        
        ，route就是你访问一个页面的地址。router就是由一群地址组成的东西。
        
        
        硬件的路由，是告知请求者，所请求的ip在哪里，并且把请求抛过去。
    web框架的路由，是告知框架，所请求的http参数应该调用的模块、类、方法在哪里，并且（或是由框架）把请求抛过去。
    
    
    
    我们在使用 Vue 或者 React 等前端渲染时，通常会有 hash 路由和 history 路由两种路由方式。hash 路由：监听 url 中 hash 的变化，然后渲染不同的内容，这种路由不向服务器发送请求，不需要服务端的支持；history 路由：监听 url 中的路径变化，需要客户端和服务端共同的支持；我们一步步实现这两种路由，来深入理解下底层的实现原理。我们主要实现以下几个简单的功能：监听路由的变化，当路由发生变化时，可以作出动作；可以前进或者后退；可以配置路由；
    
    作者：小蚊子
    链接：https://zhuanlan.zhihu.com/p/130995492
    
    
    
    由的目的是用于解析请求的URL来确定Controller和Action。Web API默认路由是通过http的方法（get/post/put/delete）去匹配对应的action，也就是说webapi的默认路由并不需要指定action的名称，当然，WebApi也支持MVC里面的路由机制，但RestFul风格的服务要求请求的url里面不能包含action，所以，在WebApi里面是并不提倡使用MVC路由机制的。下边通过例子介绍Web API路由原理以及使用。
    
    作者：码探长
    链接：https://zhuanlan.zhihu.com/p/172528608
    
    
    浏览器当前的 URL 发生变化时，路由系统会做出一些响应，用来保证用户界面与 URL 的同步。随着单页应用时代的到来，为之服务的前端路由系统也相继出现了。
    ```

    



## 接收请求

### 处理器和处理器函数

*   处理器 

    ```go
    type Handler interface {
        
        // Request : 客户端发送的 http 请求
    	// responseWriter : 服务器通过此接口发送给 客户端 响应信息
        ServeHTTP(ResponseWriter, *Request)
    }
    ```

*   处理器函数

    ```go
    // 处理器
    type HandlerFunc func(ResponseWriter, *Request)
    
    // handler 处理器，表示执行时间被处罚以后，负责对时间进行处理的回调函数
    
    func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request)
    ```

    

### 多路复用器

```go
默认多路复用器

	var DefaultServeMux = &defaultServeMux

    var defaultServeMux ServeMux
    Servemux 有一个方法实现了 handler 接口 ，所以 defalut 实现了handler 和 serveMux
    所以
        DefaultServeMux 不仅是一个多路复用器还是一个处理器
        它唯一要做的事就是根据 请求的 URL 将请求重定向到不同的处理器

多路复用器

	type ServeMux
    func NewServeMux() *ServeMux
    func (mux *ServeMux) Handle(pattern string, handler Handler)
    func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))
    func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string)
    func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)  // 实现 header 接口

// 综上
 多路复用器 也是一种处理器
```

### 路由

```go
 // 服务器接收客户端的请求，通过多路复用器分发到具体的处理器
    http.ListenAndServe(addr string, handler Handler) error

        addr : 默认80端口
        handler : 
            1.普通处理器				：只处理一种请求
            2. nil (默认多路复用器)		：处理多路请求
            3. 自定义多路复用器		    ：处理多种请求


// 自定义路由
    // 创建 Server 结构，
    server := http.Server{
        Addr : ":8080",
        Handler : &myHandler,  // 处理器函数
        ReadTimeout : 2*time.Second
    }+
    server.ListenAndServe()
```







## 请求处理

```go

```































































































































































































































