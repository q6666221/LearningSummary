## 题目

```go
给定两个数组，计算出两个数组的交集

// 例子
num1 = [1,2,2,4]  	num2 = [2,2]   		输出 [2,2]
nums1 = [4,4,9,5]		nums2 = [9,4,9,8,4]	输出 [4,4,9]

// 附加
1. 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。
2. 我们可以不考虑输出结果的顺序。
```

## 暴力算法

```go
两个指针分别指向两个数组

*   如果指针指向的值相等，就把该值存入空白数组，两个指针都向后移动一位
*   如果不相等 ：让较短的数组的指针向后移动
    *   找到相等的值，较短的数组的指针向后移动
    *   找不到相等的值，移动到最后，移动长数组的指针，
*   缺点 ： 貌似短的数组都要进行遍历一遍
```

*   优化

    *   将两个数组进行排序，使之成为顺序一致的
    *   两个指针分别指向两个数组的第一个元素
    *   开始进行遍历比较两指针对应的值
        *   相等，双方都向后移动一个位置 , 将结果添加到存储结果的切片中
        *   不等，数据小的一方向后移动一个位置

    ```go
    // 从中途往后遍历，节省前面比较的时间
    // 从小的一方开始遍历： 能够节省遍历的次数，很容易停到最后一个位置 ？？？？？？？？？？？
    
    func Intersect(nums1 []int, nums2 []int) []int {
    
        // 游标指针
        i,j:= 0
        var result []int
        sorts.Ints(nums1)
        sorts.Ints(nums2)
        for( i<len(nums1) && j<len(nums2) ) {
            if nums1[i] ==  nums2[j] {
                append(result,nums[i])
                i++
                j++
            }
    
            if nums[i] > nums2[j] {
                j++
            }
            if nums[i] < nums2[j] {
                i++
            }
        }
        return result
    }
    ```

    



## 转换映射

*   有限制：元素出现的次数，所以就要知道此信息
*   转化成 《元素，出现的次数》

```go
func Intersect(nums1 []int, nums2 []int) []int {

	m := make(map[int]int)

	// 将结果存入该切片
	var result = []int{}

	for _, v := range nums1 {
		m[v] += 1

	}

	for _, v := range nums2 {
		// 存在相等值
		if m[v] > 0 {
			result = append(result, v)
			m[v] -= 1
		}
	}
	return result
}
```



## 优化

```go
// 结果可以存储在 使用过的 数组中，可以节省内存，
// 为了逻辑更加清楚，还是不用为好
for _,v := range nums2 {
    if m[v] > 0 {
        buns2[k] = v
        m[v]--
    }
}
return nums2
```

