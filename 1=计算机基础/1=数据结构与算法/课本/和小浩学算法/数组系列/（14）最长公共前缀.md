## 题目

```go
写一个函数查找字符串中的最长公共前缀，如果不存在公共前缀，则返回 ""
字符串都要是小写的 , 是公共前缀


例子 ：
输入: ["flower","flow","flight"] 
输出: "fl"

输入: ["dog","racecar","car"] 
输出: ""

```

## 思路

*   既然是公共前缀，所以是每个元素就有的，

*   从一个元素入手截取字符串，然后看其他元素是否有就行了

    *   选取整个元素，从后往前截取，将不符合的字母剔除

    ```go
    输入: ["flower","flow","flight"] 
    输出: "fl"
    
    1. 选取元素 flower
    2. flower 作为子串，判断是否术语剩余的 "flow","flight" 子串
    3. 不是。就将 flower 去最后一个字母的flowe ,然后判断其是否是剩余对象的子串
    4. 不是。flowe 再去最后一个元素 ：flow  在判断其是否为剩余对象的子串
    5. 一次类推 ，直到 fl
    6. fl 是剩余元素的子串，就返回 fl
    ```

    



## golang

*   涉及的知识

    ```go
    // 子串 sep 在字符串 s 中第一次出现的位置，子串 sep 第一个元素所在位置
    // 不存在则返回-1
    //  你可以理解成 s 中的 sep 的位置
    func Index(s, sep string) int
    
    
    golang 中字符串截取（注意：中文和英文的不一样）
    ```

    

*   实现

    *   从后往前比较

    ```go
    // 输入: ["flower","flow","flight"] 
    // 输出: "fl"
    
    func longestCommonPrefix(strs []string) string {
    	pre := strs[0]
    	for _, v := range strs {
    
            // 前缀循环截取，依次去掉最后一个元素
    		for strings.Index(v, pre) != 0 {
    			if len(pre) == 0 {
    				return ""
    			}
    			pre = pre[:len(pre)-1]
    		}
    
    	}
    	return pre
    }
    ```

    

    *   从前往后比较

    ```go
    // 输入: ["flower","flow","flight"] 
    // 输出: "fl"
    
    func longestCommonPrefix(strs []string) string {
        pre := strs[0][:1]
    	for _, v := range strs {
    		for strings.Index(v, pre) != 0 {
    			if len(pre) == 0 {
    				return ""
    			}
    			pre = pre[:len(pre)-1]
    		}
    
    	}
    	return pre
    }
    
    ```

    