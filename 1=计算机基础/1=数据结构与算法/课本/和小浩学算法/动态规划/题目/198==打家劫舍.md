

## 题目

```go
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

// 示例一
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

// 实例二
输入：[1,3,9,5,6,17]
输出：27
解释：偷窃 1 号房屋 (金额 = 1), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 17)。
     偷窃到的最高金额 = 1 + 9 + 17 = 27 。


    0 <= nums.length <= 100
    0 <= nums[i] <= 400

```

## 分析

```go
// 对于实例二的解释
1 直观看
	第一眼看，我是去寻找怎样才能从 9 然后直接取到 17 然后就陷入思维的误区，然后就一直在找怎么调过去
	咋说呢，这个一下子就被自己的眼睛带偏了，好吧完全版没有思路

	取数据长度的一半 ， 确定需要乐观估计需要多少个数据（进一法 ：5个数的话取3 个）
	貌似你需要排序，然后从大到小挑选数字，选出来不相邻的数字，直到挑选出所有需要的数字，然后求和
	

2.利用动态规划
	后面偷得钱回收前面的钱的影响，应为后面的钱是前面的钱的总和
	其实这就是前面的后面的结果受到勤勉结果的影响
	那么怎么才会实现 9 以后不偷 6 ，而是直接去偷 17 呢？假如后面还有小的数字，该怎么取舍呢？
	
	
```

*   动态规划

    ```go
    [3,1,1,9,5,6,17]
    // 这个我们可以很清晰看到应该选 3 9 17 ，但是关注点儿不要关注于挑选这这个数字。
    // 对问题进行分层 、 条件限制
    // 分层就是问题在复杂，他还是在基础的问题上发展而来: 本题就分为小偷偷金币 + 隔间才能偷
        // 偷东西 ： 前面偷得越多，后面再偷，得到的也就越多,前面依赖后面
        // 隔间偷 ： 给动态规划添加条件限制
    
    [3] 
    	只有一个，只能选他了
    	dp = [3]
    [3,1]  
    	两个就要考虑隔壁的房间不能偷，所以二选一，选择最大的就是了
    	dp = [3,3]
    [3,1,1]
    	三个房间就要考虑隔一个房间的问题了
    
    	[i-2 ,i-1,i]
    	小偷在第 i 个房间决定偷不偷
    	隔一个房间的条件，所以偷的话 ： dp[i] = dp[i-2]+a[i] （隔着偷）
    					不偷的话 ： dp[i] = dp[i-1]
    	偷得条件 ： dp[i-2]+a[i] > dp[i-1]
    	dp = [3,3,4] 这样就相当于在最后一个位置取得是第一、三个房间，就跳过了中间那个
    
    [3,1,1,9] dp = [3,3,4]
    	
    	有四个房间，在第四个房间偷得钱  dp[3] = dp[1] + a[3] = 3 + 9 
    	这个房间不偷的话 ，dp[3] = dp[2] = 4
    	比较的话就偷 这个房间 dp = [3,3,4,12]
    	就相当于 偷了 3 9 
    
    [3,1,1,9,10] dp = [3,3,4,12]
    	在第五个房间 偷的话 dp[4] = dp[2] + a[4] = 4 + 10 = 14
    	不偷的话 dp[4] = dp[3] = 12
    	比较的话 就是偷 dp = [3,3,4,12,14]
    	就是偷了 3 1 10
    
    	
    其实这道题间隔一件房子不能偷：其实就是最多间隔两个房间，最少隔离一个房间
    条件 dp[i] = dp[i-2] + a[i] （挨着的不偷）
    
    不要光想着如何去跳，就像只有四个房间的时候，你挑选 3 9 ，然后可能就会打断动态规划的思路了
    你要去想，这个问题是不是在前面的问题的基础上去解决的，不要直接一上去就被结果打断了思路
    结果越容易看到，你越容易去根据结果去理思路，而不是从基础思路去推出来结果
    
    
    要想想你用到了什么知识点儿
    ```

## golang 实现

### 基础思路

```go
func rob(nums []int) int {
    if len(nums) < 1 {
        return 0
    }
    
	if len(nums) == 1 {
        return nums[0]
    }
    
    if len(nums) == 2 {    
        return max(nums[0],nums[1])
    }
    
    
    // 用来存放，在第 i 个房间，小偷到手的钱数
    dp := make([]int,len(nums))
    
    dp[0] = nums[0]
    dp[1] = nums[1]
    

    
    for i:=2;i<len(nums);i++{
        dp[i] = max(dp[i-2]+nums[i],dp[i-1])
    }
    
    return dp[len(nums)-1]
}

func max(a,b int) int {
    if a > b {
        return a
    }     
   return b
}
```

### 优化

```go
基础部分，需要 dp 来存储每一步产生的结果
但是，由于每次操作过 nums[i] 以后，就不再回来操作这个未知的数字了，所以，可以把结果存处在对应的位置就可以了，节省下内存
```













































































































































































