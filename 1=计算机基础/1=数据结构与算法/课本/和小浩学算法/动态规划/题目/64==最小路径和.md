## 题目

*    由120变形而来

```go
给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

// 示例
输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
```



## 思路分析

```go
1. 特殊位置的元素
	最上边 ： 只能从左边来
	最左边 ： 只能从上边来
	最右边 ： 只能往下
	最下边 ： 最能往右走
2. 路径只能往右户或者往下
```



## golang 实现

### 思路实现

```go
func minPathSum(grid [][]int) int {
    if len(grid) < 0 {
        return 0
    }
     
    result := make([][]int,len(grid))
    for i,v := range grid {
        reslut[i] = make([]int,len(grid[i]))
    }
    result[0][0] = grid[0][0]
    
    
    // 一行一行来计算每一行的，有一定的顺序
    
    // 第一行
    for i:=0;i<len(grid);i++{
        // 逐列进行计算
        for j:=0;j<len(grid[i]);j++{
            // 跳过 了 result[0][0]
            // 最上面一列
            if i == 0 && j != 0  {
                result[i][j] = result[i][j-1] + grid[i][j]
            // 最左边的一列
            } else if i != 0 && j = 0 {
                result[i][j] = result[i-1][j] + grid[i][j]
            
            // 普通的，直接对比找上面两个
            } else {
                result[i][j] = min(result[i][j-1],result[i-1][j]) + grid[i][j]
        }
    }
        // 数组维数 , 有几维
        length :=  len(result)
        return result[length-1][len(result[length]-1 ]
}
```

### 优化

``` 
在我们自左上角到右下角计算各个节点的最小路径和的过程中，我们只需要使用到之前已经累积计算完毕的数据，并且不会再次访问之前的元素数据

所以将 result[i][j] 全都放在  grid[i][j] 的位置中
```

