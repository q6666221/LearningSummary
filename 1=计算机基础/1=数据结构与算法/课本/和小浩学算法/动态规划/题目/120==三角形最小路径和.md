## 题目

```go
给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。


// 示例
[
     [2],
    [3,4],
   [6,5,7],
  [4,3,8,2]
]
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 3 = 13）。

// 说明：
	如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。
//----------------------------------------------------------------------------------------

// 转化成正常的
2
3 4
6 5 7
4 3 8 2
按照规则： 每一步只能移动到其下面和右下角
就像三层的 5 ，通过 5 只能找到 3 和 8 ，查找不到 2
```



## 思路

## golang 实现

### 思路代码

```go
func minimumTotal(triangle [][]int) int {
    
    
    
    if len(triangle) < 1 {
        return 0
    }

    
    //  表示包含第i行j列元素的最小路径和
    // j 列是有两个路径的，除了最左边和最右边的两个元素
    result := make([][]int,len(triangle))
    for i ,arr := range triangle {
        result[i] = make([]int,len(arr))
    }
    
    result[0][0] = triangle[0][0]

    // 初始值
    res := result[0][0]
    
	if len(triangle) == 1 {
        return res
    }

    
    // 行查询
    for i:=1; i<len(triangle); i++ {
        // 列查询
        for j:=0; j<len(triangle[i]);j++ {
            
            // 最左边的元素
            if j == 0 {
                result[i][j] = result[i-1][j] + triangle[i][j]
                continue
            }
            
            // 最右边的元素
            if j == len(triangle[i]) {
                result[i][j] =  result[i-1][j-1] + triangle[i][j]
                continue
            }
            
            // 中间的元素
            // min(result[i-1][j-1],result[i-1][j]) 当前元素的前面两个
            result[i][j] = min(result[i-1][j-1],result[i-1][j]) + triangle[i][j]
            
        }
    }
    
    // 对最后一行的的结果进行遍历
    for _, v := range result[len(result)] {
        res = min(res,v)
    }  
    return res               
}

func min(a,b int) int {
    if a > b {
        return b
    }
    
    return a
}
```

### 优化内存

```go
对于 triangle[i][j] 计算过以后，就不会再使用了
所以 result[i][j] 可以放在 对应的 triangle[i][j] 的位置，方便节约内存
//-----------------------------------------------------------------------------------------
```

