## 题目

*   **最长上升子序列**（Longest Increasing Subsequence，LIS）

```go
给定一个无序的整数数组，找到其中最长上升子序列的长度。

// 示例
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。

// 说明

    可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
    你算法的时间复杂度应该为 O(n2) 。

// 进阶
你能将算法的时间复杂度降低到 O(n log n) 吗?
```

## 思路

```go
1. 这种序列可以是挨着的，也可能是非连续的
2. 用一个额外的数组来存储各个元素对应的在上升子序列中的序号
3. 每找到一个就跟前面的元素进行对比，来确定应该确定的
4. 如果你查找到的那个元素比所有元素都小，那这个元素要从零开始
    5 6 2  // 2 和 5 的上升序列下标都是 1
    5 6 2 7   // 7  的上升序列下标应该是 3 ，并非是 2
	5 6 2 7 7  // 第二个 7 的下标应该是 3，
```



## golang 实现

```go
func lengthOfLIS(nums []int) int {
    
    if len(nums) < 1 {
        return 0
    }
    
    // 存放每个元素应该对应的上升子序列中的下标
    resSlice := make([]int,len(nums))

    // 需要打印出来的初始值（最少要有一个元素）
    res := 1
    
    
    // 取到元素
    for i:=0; i<len(nums); i++ {
        
        // 默认当前元素是其及前面所有元素最小的
	    resSlice[i] = 1
        
        // 取到的元素和前面已经取到的元素进行对比，确认相应的序列序号
        for j:=0; j < i; j++ {
            if nums[i] > nums[j] {
                // 取 nums[i] 应有的是最大的值
                resSlice[i] = max(resSlice[j]+1 , resSlice[i])
            }
        }
        // 当前最大值作为要输出的值
        res = max(res , resSlice[i])
    }
}

func max(a,b int) int {
    if a > b {
        return a
    }
    return b
}
```

