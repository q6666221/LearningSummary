

## 介绍

## 特点

*   每个结点最多有两个结点，即两颗子树
    *   称为左子树、右子树
    *   最多有两个，可以只有一个，也可以没有
*   本身是有序树
    *   左子树和右子树是有顺序的，次序不能任意颠倒
*   即使树中某结点只有一个子树，也要区分他是左子树还是右子树



## 形态

*   空二叉树
*   只有一个根结点
*   根结点只有左树
*   根结点只有右树
*   根结点既有左树又有右树

## 分类

参看树族

 [树族.md](二叉树族\树族.md) 

## 性质

*   1、在二叉树的第 i 层上至多有 $ 2^(i-1) $个结点。（ i >= 0）

*   2、深度为 k 的二叉树至多有  $(2^k) -1$  个结点  ( k >= 1 )

*   3、对任何一裸二叉树 T，如果其终端结点数为 n0 ，度为 2 的结点数为 n_2

    ```go
    n0 = n2 + 1
    ```


*   4、具有 n 个结点的完全二叉树的深度为  |log2n| - 1 ( |x| 表示不大于x 的最大整数

*   5、

    ![1598032843154](1598032843154.png)

## 存储结构

### 顺序存储结构

*   实现树的一对多的关系比较困难，但是二叉树比较特殊，完全可以实现

*   结点设置

    *   将二叉树按照满二叉树的结构进行编写序号(按层进行编号)
    *   不存在的结点设置为 ^ 或者nil

*   适用

    *   只用于完全二叉树
    *   顺序存储普通二叉树，需要提前将普通二叉树转化为完全二叉树。 

*   存储

    *    需从根节点开始，按照层次依次将树中节点存储到数组即可 

    *   数组下标 即为 节点的编号，对于不存在的结点，其内容设置为 0 或者空

        ![1598099154881](1598099154881.png)

### 链表存储结构



#### 孩子表示法 - 二叉链表

*   本质
    *   线索链表 - 参看线索二叉树
    *   链表存储
    
*   结点

    ![1598060050461](1598060050461.png)

    ```go
    // 二叉链表结点结构
    type BiTNode struct {
        data interface{}  // data 数据域
        lchild	*BiTNode  // lchild 指针域；存放指向左孩子的指针
        rchild	*BiTNode  // rchild 指针域； 存放指向右孩子的指针
    }
    
    // 优化成 孩子双亲表示
    可以增加一个记录双亲结点的字段，实现孩子双亲表示法
    	
    ```

*   结构示意图

    ![1598060314506](1598060314506.png)


## 遍历

*   traversing binary tree

*   是指从根结点出发.按照某种次序依次访问二叉树中所有结点。使得每个结点被访问一次
    且仅被访问一次。

    ```mermaid
    graph LR
    遍历 --> 深度优先
    遍历 --> 广度优先
    
    深度优先 --> 前序遍历
    深度优先 --> 中序遍历
    深度优先 --> 后序遍历
    广度优先 --> 层次遍历
    ```

    

    ![1598073832111](1598073832111.png)



### 前序遍历

*   根 - 左子树 - 右子树

    ```go
    // 根   A _ _  : A 左孩子 右孩子
    1.根据根-左-右	A  B  C
    2.然后将 B C 的 左孩子 右孩子填进去  
    	A  B D _ C E F
    3.填进去 D E F 的左孩子 右孩子
    	A  B D G H _ C E _ I F _ _ 
    4.然后将占位符号给去掉，就是遍历的顺序
    	A  B D G H C E I F 
    ```

*   思想

    1.   访问根节点；
    2.   访问当前节点的左子树；
    3.   若当前节点无左子树，则访问当前节点的右子树；

*   遍历顺序 ： A B D G H C E I F

*   前面、左边开始

    ![1598061812188](1598061812188.png)

### 中序遍历

*   左孩子 - 根 - 右孩子

    ```go
    // 先从根结点开始，补全模式，然后把补全进来的结点当成子树根结点，然后进行本模式补充
    // 左孩子 - A - 右孩子
    1.根  _ A _ ： B A C
    2.然后将 B C 的 左孩子 右孩子填进去
    	D B _ A E C F
    3.填进去 D E F 的左孩子 右孩子
    	G D H B _ A _ E I C _ F _ 
    4.然后将占位符号给去掉，就是遍历的顺序
    	G D H B A E I C F
    ```

*   思想

    1.   访问当前节点的左子树；
    2.   访问根节点；
    3.   访问当前节点的右子树；

![1598063977512](1598063977512.png)

### 后序遍历

*   左 - 右 - 根

    ```go
    // 根   _ _ A  : 左孩子 右孩子  A 
    1.根据根-左-右	  B C A
    2.然后将 B C 的 左孩子 右孩子填进去   _ _ B _ _ C A
    	D _ B E F C A
    3.填进去 D E F 的左孩子 右孩子  _ _ D _ B _ _ E _ _ F C A
    	G H D _ B _ I E _ _ F C A
    4.然后将占位符号给去掉，就是遍历的顺序
    	G H D B I E F C A 
    ```

*   思想

     从根节点出发，依次遍历各节点的左右子树，直到当前节点左右子树遍历完成后，才访问该节点元素。 

    

![1598065210560](1598065210560.png)

### 遍历方式

#### 层序遍历

*   广度优先 BFS  + 栈

    ```go
    // 宽度优先
    从根结点开始一层一层开始遍历
     同一层从左到右
     一层一层开始遍历
    ```


![1598066212074](1598066212074.png)

#### 深度遍历

*   深度优先  ++  递归循环

```go
//  Depth First Search

树的深度遍历树的节点，尽可能深的搜索树的分支，这一过程一直进行到已发现从源节点可达的所有节点为止。
即 ： 沿着一个方向一直向下遍历。

// 缺点
1. 递归中，如果层级过深，我们很可能保存过多的临时变量，导致栈溢出。
```



### 判断树

*   根据树遍历确定一棵树
    
    *   必须要有中序遍历，中序确定根结点
    
*   思路

    ```go
    中 + 前 ：根在最前
    中 + 后 ：根在最后
    ```


## 相关知识

*   具体到相关的知识点儿去看

    ```js
    1. 二叉树的度  ：  参看树的度
    2. 回溯算法
    ```

    



## 二叉树种类数判断

*     每一棵普通树对应的都是一棵没有右子树的二叉树，所以对于 n 个结点的树来说，树的形态改变是因为除了根结点之外的其它结点改变形态得到的 
*     n 个结点构建的形态不同的树与之对应的是 n-1 个结点构建的形态不同的二叉树。
*     公式
      *    tn 表示 n 个结点构建的形态不同的树的数量，
      *    bn 表示 n 个结点构建的形态不同的二叉树的数量，
      *    两者间关系：`tn=b(n-1)`。
      *    计算方法
           *   没看懂........



































































































