## 1. 认识

*   英语：Insertion Sort
*   是一种简单直观的排序算法。
*   8 6 5 7 利用插入排序得出 8 7 6 5 ，就像把 7 插入到 8 6 中间，所以叫插入排序

## 2.工作原理：

*   通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
*   插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

## 3. 用处

* 小规模数据
* 数据基本有序，数据有序程度越高，越高效
* 大量的移动和比较，会导致算法效率低下

## 4.稳定性

## 5.问题

*   如何构造初始有序序列
*   如何查找待插入记录的位置

## 6.思路处理

```go
// 个人感觉就是： 从后向前的冒泡排序 , 冒泡直接两个进行比较，插入是用一个中间两存储过度下
```



## 7.思路例子

*   总结

    ```go
    1. 需要两层循环
    	1 层循环向后，去取无序的
    		2 层 循环向前，取和有序的比较
    ```

    

*   例子

    ```go
    a = [ 39 , 87 , 20 , 71 , 43 ]
    手动排序 
    a = [ 20 , 39 , 43 , 71 , 87 ]
    ```

*   第一个数据 

    ```go
    // 此位置的数据，当成默认的有序序列的初始值
    	a = [ 39 || 87 , 20 , 71 , 43 ]    // 格式 有序的序列 || 无序的序列
    
    // 注意
    	默认第一个数据是有序序列的第一个值
    ```

    

*   第二个数据 

    ```go
    a = [ 39 || 87 , 20 , 71 , 43 ]
    第二个数据 87 
    87 > 39 ,不动
    
    结果 ： a = [ 39 ， 87 || 20 , 71 , 43 ]
    ```

*   第三个数据 

    ```go
    a = [ 39 ， 87 || 20 , 71 , 43 ]
    第三个数据  20
    
    20 < 87 , 所以 20 和 87 交换一个位置
    20 < 39 , 所以 20 和 39 交换一个位置
    结果 ： a = [ 20 ， 39 ， 87 || 71 , 43 ]
    ```

 *   第四个数据 

     *   套路跟第三个一致

      ```go
      a = [ 20 ， 39 ， 87 || 71 , 43 ]
     
     第三个数据  20
     
     71 < 87 , 所以 71 和 87 交换一个位置
     71 > 39 , 所以 71 和 39 不交换位置 然后进行下一个元素比较
     
     结果 ： a = [ 20 ， 39 ，71 , 87 ||  43 ]
      ```

*   第五个数据 

    *   套路跟第三个一样

    ```go
    a = [ 20 ， 39 ，71 , 87 ||  43 ]
    第五个数据
    43 < 87 , 所以 43 和 87 交换一个位置
    43 < 71 , 所以 43 和 71 交换一个位置
    43 > 39 , 所以不交换位置 结束比较
    
    结果 ： a = [ 20 ，39 ，43 ，71 , 87 ]
    ```

## 8.性能分析

*   时间复杂度
    *   最好情况
        *   比较次数  n - 1        移动次数 ：2（n-1）
        *   时间复杂度  $O(n)$
    *   最坏情况（逆序或者反序）
        *   比较 n-1 次				移动 n * n 次，即：每次都要比较都要交换
        *   时间复杂度 $O(n^2)$
*   空间复杂度
    *   需要一个记录的辅助空间

