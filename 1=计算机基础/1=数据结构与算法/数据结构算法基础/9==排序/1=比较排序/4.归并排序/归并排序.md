## 介绍

*   Merge Sort 
*   百度百科： [归并排序](https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F)

## 稳定性

*   稳定

## 用途

*   一般用于对总体无序，但是各子项相对有序的数列
*   速度仅次于快速排序

## 思路

*    先递归分解数组，再合并数组。 

*   拆分
    *    进行的排序序列分为左右两个部分，
        *   进行排序的序列
            *   起始元素下标为first，
            *   最后一个元素的下标为last，
            *   那么左右两部分之间的临界点下标mid=(first+last)/2，
            *   这两部分分别是 A[first … mid] 和 A[mid+1 … last]
    *    两部分序列继续按照上面继续进行划分，直到划分的区间长度为1 
*   合并
    *    执行归并排序 
    *     对所分的n个子序列进行两两合并，得到n/2或n/2+l个含有两个元素的子序列，再对得到的子序列进行合并，直至得到一个长度为n的有序序列为止 

*   注意

    *   拆分的时候，

        ```go
         A[first … mid] 和 A[mid+1 … last]前面那个不包括 mid
        // 正常截取，在切片个数是奇数的时候，会导致最左边的切片会出现空的情况
        mid = len(a) / 2
        // 确定左边的一定是偶数个数据元素
        mid = len(a) / 2 + len(a) % 2
        ```

*   demo

    ```go
    package main
    
    
    func merge(left ,right []int) []int {
    	var result []int
    	for len(left) != 0 && len(right) != 0 {
    		if left[0] <= right[0] {
    			result = append(result, left[0])
    			left = left[1:]
    		} else {
    			result = append(result, right[0])
    			right = right[1:]
    		}
    	}
    
    	for len(left) != 0 {
    		result = append(result, left[0])
    		left = left[1:]
    	}
    
    	for len(right) != 0 {
    		result = append(result, right[0])
    		right = right[1:]
    	}
    
    	return result
    
    }
    
    func mergeSort(a []int) []int {
    
    	length := len(a)
    	if length < 2 {
    		return a
    	}
    
    	// 确保前面的数据始终是偶数个的
    	mid := length / 2 + length % 2
    
    	// 取左边
    	left := mergeSort(a[0:mid])
    	// 取右边
    	right := mergeSort(a[mid:])
    	// 进入递归
    	// 这里有一个逻辑，就是 left 没有归，就会一直递下去 ，
    	// 同时有一个right 等待执行，而 right 进行回溯的时候，其中的其中的切片，正好是上层的两个元素
    	// 最后一层 left 归的时候，
    	// 递归到底层的时候，就不
    	return merge(left,right)
    
    }
    ```

    