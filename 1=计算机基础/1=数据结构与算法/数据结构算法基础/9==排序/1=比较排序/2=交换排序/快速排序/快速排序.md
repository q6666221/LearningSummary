## 思路

1.  先从数列中取出一个数作为基准数。一般取第一个数。
2.  分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。
3.  再对左、右分区根被选择一个基准数，重复2
4.  重复3，直到各区间只有一个数

## 例子思路

```go
// 一般取第一个数 5 作为基准，从它左边和最后一个数使用[]进行标志，
如果左边的数比基准数大，那么该数要往右边扔，也就是两个[]数交换，这样大于它的数就在右边

开始选择第一个基准数字  5
left 左边的[]	right 右边的[]
[5] 9 1 3 [8]	因为 8 > 5，不交换，右边的[] 左移
[5] 9 1 [3] 8	因为 3 < 5，两个[]的数据交换 ，交换后 ，左边的[] 右移
3 [9] 1 [5] 8	因为 9 > 5，两个[]的数据交换 ，交换后 ，左边的[] 右移
3 [1] [5] 9 8	因为 1 《 5，两个[]的数据交换 ，交换后 ，左边的[] 右移
3 1 [[5]] 9 8    此时两边的 [] 重合，此时停止比较交互
	5 的左边为 3 1 ，都比 5 小
	5 的右边为 9 8 ，都比 5 大
	然后对左右两边的数组分别重复 5 一样的操作，一直到 两边只剩到一个元素
```



## 时间复杂度计算

*   最好情况计算

    ```go
    最好情况，每一轮都能平均分切，这样只要 n/2 次就可以把数列分成两部分，每一轮的时间复杂度都是 O(n)
    问题每次折半，折半的数列继续切分，也就是总的时间复杂度计算公式为 T(n) = 2*T(n/2) + O(n)
    
    T(n) = 2*T(n/2) + n/2
    T(n/2) = 2*T(n/4) + n/4
    T(n/4) = 2*T(n/8) + n/8
    T(n/8) = 2*T(n/16) + n/16
    ...
    T(4) = 2*T(2) + 4
    T(2) = 2*T(1) + 2
    T(1) = 1
    
    T(n) = 2*T(n/2) + n/2
         = 2^2*T(n/4)+ n/2 + n/2
         = 2^3*T(n/8) + n/2 + n/2 + n/2
         = 2^4*T(n/16) + n/2 + n/2 + n/2 + n/2
         = ...
         = 2^logn*T(1) + logn * n/2
         = 2^logn + 1/2*nlogn
         = n + 1/2*nlogn
    
    因为当问题规模 n 趋于无穷大时 nlogn 比 n 大，所以 T(n) = O(nlogn)。
    
    最好时间复杂度为：O(nlogn)。
    ```

*   最坏情况

    ```go
    每次都不能平均地切分，每次切分都因为基准数是最大的或者最小的，不能分成两个数列，这样时间复杂度变为了 T(n) = T(n-1) + O(n)，按照主定理计算可以知道时间复杂度为：O(n^2)
    
    
    我们来分析最差情况，每次切分遍历元素的次数为 n
    
    T(n) = T(n-1) + n
         = T(n-2) + n-1 + n
         = T(n-3) + n-2 + n-1 + n
         = ...
         = T(1) + 2 +3 + ... + n-2 + n-1 + n
         = O(n^2)
    
    最差时间复杂度为：O(n^2)。
    ```


## 改进

### 组合插入排序

*   优势
    *   在小规模数组的情况下，直接插入排序的效率最好，当快速排序递归部分进入小数组范围，可以切换成直接插入排序。

### 三向切分

*   优势
    *   排序数列可能存在大量重复值，使用三向切分快速排序，将数组分成三部分，大于基准数，等于基准数，小于基准数，这个时候需要维护三个下标。

### 尾递归

*   优势
    *   使用伪尾递归减少程序栈空间占用，使得栈空间复杂度从 `O(logn)~log(n)` 变为：`O(logn)`
*   





## 需要总结

```go
https://zhuanlan.zhihu.com/p/119079995
```





## 参考

```go
1. https://zhuanlan.zhihu.com/p/119079995
```

































































































































































