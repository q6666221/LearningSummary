# 1.单链表

* 链表的每个结点只包含一个指针域

* # 注意

    * 关于初始化

        ```go
        // 对于 head 是指向 nil ,还是指向头结点，都可以
        // 对于使用不使用 length 来记录链表长度，都随意，有的话可能会更好点
        ```

        

### 1、有头结点

* ## 图示在ppt上

* ## 追加在前面

    ```go
    1、关于 node doublelist 创建初始化
    	可以不用 createxxx 函数，因为 go 中会默认给这两个结构体默认值的
    2、关于 node 结点，可以使用结构体复制来创建，但是要使用 &node{}
    ```

    

* ## demo

```go
package main

import (
	"errors"
	"fmt"
)

// 关于循环的计数 结点指针问题

// 结点结构
type Node struct {
	data interface{} //注意 空接口可以实现 任意数据类型
	next *Node
}

// 链表结构
// 这个，有的有，有的没有，不过有是最好的
type SingleList struct {
	head   *Node //头结点
	length int   //长度  这里链表长度不计入头结点
}
========================================================
// 结点
// 要改变 func 以外的数据，所以使用地址传递
---------------------------------
// 可以直接使用 &Node{
//              	data : data, //注意 空接口可以实现 任意数据类型
// 			   		next :nil
//				}
---------------------------------
// 要改变 func 以外的数据，所以使用地址传递
func CreateNode(data interface{}) *Node {
	return &Node{data, nil} //go 对应的是初始值，没有 null none ,所以使用 nil
}
========================================================
// 链表,是有头结点的
func CreateSL() *SingleList {

	return &SingleList{CreateNode(nil), 0} // 结构体的初始默认值就是 nil
	// [ return &LList{nil, 0} ]
	// 感觉用这个更好，初始化没什么都不存在，就是个 nil
	// 但是根据 go 中结构体的默认值 是和里面的字段有关的，所以使用了 createnode,里面是 （nil nil）

}

// 遍历

func PrintSL(singlelist *SingleList) {

	// 头结点是只是存储了第一个结点的指针

	cur := singlelist.head.next // 第一个数据结点
	if cur == nil {             // 空链表退出，防止 空指针错误
		fmt.Println("kongde")
	} else {
		for { // 非空列表进行遍历打出
			fmt.Printf("%v\t", cur.data) // 卸载前面会引发 nil 空指针
			if cur.next == nil {
				break
			}
			cur = cur.next
		}
	}
	fmt.Println() //结果运行完了，在进行下换行
}

// 查询
func (this *SingleList) Search(data interface{}) int {

	// 因为这里已经确认不是空链表了，所以可以考虑从第一个结点开始遍历
	//
	// 但是为了通篇的思路,都开始从头结点进行操作，懂思想就行

	cur := this.head.next // 第一个数据结点，因为头结点没有data

	if this.length == 0 {
		fmt.Println("此链表是空链表")
		return 0

	}
	// 首个数据结点开始
	for i := 0; i <= this.length; i++ {

		if cur.data == data {
			return i
		} else {
			cur = cur.next
		}
	}

	fmt.Println("不存在")
	return 0

}

// 查长
// // 注意这个地方是不打印出来，需要传给变量才行
// func (this *SingleList) Lenth() int {
// 	return this.length
// }

func (this *SingleList) Lenth() {
	fmt.Println(this.length)
}

// 判空
func (this *SingleList) Is_Empty() bool {
	if this.length == 0 {
		return true
	}
	return false
}

//插入 —— 前插入
// 基于链表结构体实现接口 Method 中的方法：
// 在 i 处插入节点（前插 ——即插入到原来的第 i 个节点之前，成为现在的第 i 个节点）
// 注意使用的是 前插入

func (this *SingleList) Insert(i int, data interface{}) {

	// 以后还要优化，这只是简单优化

	node := CreateNode(data)

	cur := this.head

	// 这个是有头结点的
	// 从头结点开始的，是把空链表考虑在内的,空链表是含有一个空结点的
	// count 是结点数量，其中头结点为 0 ，存放数据的第一个结点为 1，所以
	// 1 <= i <    SingleList.length

	for count := 0; count <= i; count++ {

		// 找到要插入结点的前一个结点
		// 这个主要是看判断的时候，指针在什么地方。因为判断了才进行下面的操作，
		// 循环的操作，指针的状态是呈现规律性变化的，所以找最开始的指针与i的状态，
		// 就能判断，你到达目的位置后指针与计数变量的相对关系

		// 此例子中 i=0 时，指针在头指针，随后进入判断操作
		// 所以找到 i 位置时,指针

		if count == i-1 {
			node.next = cur.next
			cur.next = node
			this.length++
		}
		cur = cur.next
	}

}

// 删除第几个位置的结点

func (this *SingleList) DeleteSite(i int) error {

	//判空
	if this.length == 0 {
		return errors.New("空链表无法删除")
	}

	if i < 1 || i > this.length {
		return errors.New("位置不对")
	}

	pre := this.head
	for count := 0; count <= i; i++ {
		if count == i-1 {
			pre.next = pre.next.next
			break
		}
		pre = pre.next
	}
	return nil
}

// main 函数：
func main() {

	lList := CreateSL()

	PrintSL(lList)
	
	lList.Insert(1, "插入1")

	PrintSL(lList)
	// fmt.Println(lList.Is_Empty())
	lList.Lenth()

}
```

### 2、没有头结点的







1、结构体

```go
// 结构体

// 结点结构
type Node struct{
    data interface{}    //注意 空接口可以实现 任意数据类型
    next *Node
}

// 链表结构
// 这个，有的有，有的没有，不过有是最好的 
type SingleList struct{
    head *Node //头结点
    lenth int //长度  这里链表长度不计入头结点 
}


-----------------------------------------------------------------------
// 设计接口
// 为什么要设计这个这借口呢  ？？？

type Method interface {
    Insert(i int, data interface{})    // 增
    Delete(i int)                   // 删
    GetLength() int                 // 获取长度
    Search(v interface{}) int       // 查
    isNull() bool                   // 判断是否为空
}
```



2、初始化

```go
// 结点 

// 要改变 func 以外的数据，所以使用地址传递
func CreateNode (data interface{}) *Node{
    return &Node{data,nil}   //go 对应的是初始值，没有 null none ,所以使用 nil
}

// 链表

func CreateSingleList() *SingleList{
    return &SingleList{CreateNode(nil),0}    
    // 结构体的初始值跟里面的数据有关，所以{nil,nil}, 就出现了地址，是链表的地址
    //  return &SingleList{nil,0}
    // 感觉用这个更好，初始化没什么都不存在，就是个 nil
    // 但是根据 go 中结构体的默认值 是和里面的字段有关的，所以使用了 createnode,里面是 （nil nil）
}
```

3、查看

判空

  * 第一种方法

  ```go
  func (this *SingleList) Is_Empty() bool{
      if this.lenth == 0{
          return true
      }
  }
  ```

  * 第二种方法

  ```go
  func (this *SingleList) Is_Empty bool {
      // this.head 表示头结点
      cur = this.head
      if cur.next == nil{
          return true	// 是空结点
      }
      return false
  }
  ```

* 补充 1

```go
//  return &SingleList{nil,0}
func (this *SingleList) Is_Empty bool {
      //  this.head 表示头指针
      if this.head == nil{
          return true	// 是空结点
      }
      return false
  }
```

查长

* 1.1、使用结构体中的 size



* 1.2 使用指针结尾的 nil

```go
func (this * SingleList) Lenth() int {
    a := 0
    cur := this.head
    
--------------------------------------------------------------------
    //普通从中间想到特殊
    这个有问题。这个地址最后。应该不是 nil 的
    if  cur.next == nil{
        return 0	// 空链表
    }else{
            for {
                a++		// 注意是先记数字，还是先进进行判断。顺序很重要
                if cur.next != nil {	// 非空链表
                    cur =cur.next    
                }else{
                    return a           
        		}
            }
   		 }

--------------------------------------------------------------------
// 代码改进,合并了空链表
    for {
        if cur.next == nil{
            return a	// 其实这里也是进行了一个判空操作
        }else{
            a++			// 注意是先记数字，还是先进进行判断。顺序很重要
            cur =cur.next        
        }
    }
```

* 2.1

```go
func (this * SingleList) Lenth() int {
    a := 0
    cur := this.head
==============================================================================================
    //普通从中间想到特殊
    
    if  cur == nil{	   #貌似差不符哦啊？？？？？？？？？？？
        return 0	// 空链表
    }else{
            for {
                a++		// 注意是先记数字，还是先进进行判断。顺序很重要
                if cur.next != nil {	// 非空链表
                    cur =cur.next    
                }else{
                    return a           
        		}
            }
   		 }

// 这种方法要注意，nil是没有next属性的,所以只能分两种情况
 ------------------------------------------------------------------------------------
    
```



遍历

* 1.1

```go
func PrintSingleList (singlelist *SingleList){

	// 空链表遍历
    if singlelist.Length == 0 {
        return nil
    }    
    
    // 非空链表
    // singlelist.Head是头结点，头结点的下一个是第一个数据的结点
    cur := singlelist.Head.Next  // 第一个结点，当然，也可以从 0 开始
    // 还是要判空

    for i:=1; i<=singlelist.Length; i++ {
        fmt.Printf("%v\n", cur.Data)
        pre = pre.Next
    }
}



==============================================================================================
自己进行优化
// 最好的思路就是，一个大的for 循环，然后里面进行 空的 和 非空的 进行分类讨论
    func PrintSingleList (singlelist *SingleList){
        cur := singlelist.head
        
        
  		// 空链表退出，防止 空指针错误
    	if cur.next == nil{	  	//cur.next是 nil 空指针，打印不出来的
    		fmt.Println("空的")
    	}
        
		// 非空列表进行遍历打出
		for {
			// 这个打印的位置很重要，思路想好以后，要调整顺序
			fmt.Printf("%v\t", cur.data)	// 把当前元素的 data 打印出来
			if cur.next == nil{
				break
			}
			cur = cur.next
		}
	}
 ------------------------------------------------------------------------------------
 这个可以进行优化，就是先进行 非空的判断打印 for 循环，但是这是先判断，所以要注意最后一个元素的情况
 只能先判断空链表。因为最后一个元素的 next 也是nil,不好区分此处与空链表，当然你用 size 搭配也可以
    以下代码有问题的 ！！！！！！
func PrintSingleList (singlelist *SingleList){
    cur := singlelist.head
 	for {
		// 这个打印的位置很重要，思路想好以后，要调整顺序
        // 
        
		if cur.next != nil{	//非空链表
            cur = cur.next
            fmt.Printf("%v\t", cur.data)	// 把当前元素的 data 打印出来
         }else{				// 空的链表
            return nil
        }
		return
}     
======================================================================================
```

查询

```go
// 根据元素查询所在位置

func()





// 根据位置查询此处元素
```









创建/初始化

结点

```go
// 如果放到下面的具体函数中，需要对结构体进行初始化
// 

func CreateNode (data interface{}) *Node{
    return &Node{data,nil}
}
-------------------------------------
func (n *Node) CreateNode(Date interface{}) *Node
{
    data : data //这个可以是参数吗？
    next : nil
}

--------------------------------------
// 疑点,可以这样写吗？
func CreateNode (data interface{}) *Node{
    var node Node{
        data : data //这个可以是参数吗？
        next : nil
    }
}
```







添加元素

尾部

* 空列表不涉及元素遍历
* 给空列表要进行遍历，直到最后一个元素

```go
func(this *SingleList) Append(data interface) bool {
    // 转换成结点类型
    node := Node(data)
    // 判断添加的数据是否为空
    if node == nil{
        return false
    }
    // 先把要添加的结点的下一个为 nil
    node.next = nil
    
    if this.size == 0 {
        this.tail = node
    }else{
        // 尾结点变换
        oldTail = l.tail
        oldTail.next = node
        l.size++
    }
    
}
```





# 2、双向链表

* 节点
    * pre ：记录上一个节点的位置
    * next : 记录该节点直接后继元素的节点地址
    * data : 记录数据
* 头结点 ： 
    * 没有前驱元素，所以它的 pre 是 nil



### 有头结点的

```go
package main

import (
	"errors"
	"fmt"
)

// 节点

type Node struct {
	pre  *Node
	next *Node
	data interface{}
}

// 链表的结构
type DoubleList struct {
	headNode *Node
	length   int
}

//初始化

// 头结点 创建
func CreateNode(data interface{}) *Node {
	return &Node{
		pre:  nil,
		next: nil,
		data: data,
	}
}

//初始化链表 ，初始化一个带头节点的链表
func CreateDL() *DoubleList {
	return &DoubleList{
		headNode: CreateNode(nil),
		length:   0,
	}
}

//判空
func (this *DoubleList) Is_Enpty() {
	if this.length == 0 {
		fmt.Println("True")
	}
	fmt.Println("False")
}

//长度
func (this *DoubleList) Length() {
	a := this.length
	fmt.Println(a)

}

//      ┏┛ ┻━━━━━┛ ┻┓
//      ┃　　　　　　 ┃
//      ┃　　　━　　　┃
//      ┃　┳┛　  ┗┳　┃
//      ┃　　　　　　 ┃
//      ┃　　　┻　　　┃
//      ┃　　　　　　 ┃
//      ┗━┓　　　┏━━━┛
//        ┃　　　┃   神兽保佑
//        ┃　　　┃   代码无BUG！
//        ┃　　　┗━━━━━━━━━┓
//        ┃　　　　　　　    ┣┓
//        ┃　　　　         ┏┛
//        ┗━┓ ┓ ┏━━━┳ ┓ ┏━┛
//          ┃ ┫ ┫   ┃ ┫ ┫
//          ┗━┻━┛   ┗━┻━┛
// 遍历
func (this *DoubleList) Travel() {

	//先判断特殊的，这样进行循环的时候，就不用每次都判断特殊的
	// 移动指针都要判断是否为 nil,nil没有next
	// 所以先判断是否为空

	if this.length == 0 {
		fmt.Print("")
		fmt.Println("备注这是空链表")
	}
	// cur 表示当前节点，而 cur.next 是 nil,可以给cur
	cur := this.headNode.next //第一个数据节点
	for i := 1; i <= this.length; i++ {
		fmt.Printf("%v ", cur.data)
		cur = cur.next //最后cur.next 是nil
	}
	// 前面是遍历所有种类的链表，但是对于空链表上面的打印出来没结果
	// 这里也有疑问，为什么
	// 所以下面的加一句提示
	fmt.Println()
}

// 查询
func (this *DoubleList) Search(data interface{}) (err error) {
	cur := this.headNode // 第一个数据的结点
	for i := 0; i <= this.length; i++ {
		if cur.data == data {
			fmt.Println(i)
			return
		}
	}
	return errors.New("不存在这个数据")
}

// 前叉  = 头部添加 + 尾部添加 + 中间位置
// 主要是因为 nil 没有 nil.pre ,所以要分情况说
// 所以分为 空链表 和 链表尾部添加

// 空链表头部位置添加  和  最后一个位置添加  是一样的逻辑操作
//  空链表头部添加 和 插入可以是一样的解释

// 链表中部添加
func (this *DoubleList) Insert(i int, data interface{}) {

	cur := this.headNode
	node := CreateNode(data)
	if this.length == 0 {
		//空链表
		if i == 1 {
			cur.next = node
			node.pre = cur
			this.length++
		} else {
			fmt.Println("这是空链表,只能正在第一个位置添加 / 插入数据")
		}
		return
	}

	if i > this.length || i <= 0 {
		fmt.Printf("你应该输入 1 - %d 之间的数据", this.length)
		return
	}
	// cur 在头指针处
	// 这里找到 i 的位置，通过 i 的前驱和后继，就找到了前后的元素
	// 定位到 i-1 的位置，再进入判断
	for count := 0; count < i; count++ { // 找到 i 之前的一个元素
		cur = cur.next
	} // 这个地方产出的 cur 就是 i位置的结点
	pre := cur.pre // cur 的前一个元素

	node.next = cur
	cur.pre = node

	pre.next = node
	node.pre = pre
	this.length++
}

// func (this *DoubleList) Insert(i int, data interface{}) {

// 	if i <= 0 || i > (this.length+1) {
// 		fmt.Printf("插入的数字不对,应该是 1 - %d", this.length)
// 		return
// 	}

// 	cur := this.headNode
// 	node := CreateNode(data)
// 	// 正常插入
// 	// 原先是用的 i表示的下标，为了和输入的 i 做区别，这里换成 count
// 	// 注意这里找到 i 之前的那个元素，即cur.next ,
// 	// 相当于现有 i 再有相对应的 cur,他们是一一对应的
// 	// 相当于说从第一个位置插入，空链表的第一个位置时 nil
// 	for count := 1; count < i; i++ { // 找到 i 之前的一个元素
// 		cur = cur.next
// 	}

// 	node.next = cur.next
// 	cur.next = node
// 	this.length++
// 	return
// }

// 尾部添加
func (this *DoubleList) Append(data interface{}) {
	node := CreateNode(data)
	cur := this.headNode

	//找到最后一个的位置位置
	for i := 0; i < this.length; i++ {
		cur = cur.next
	} // 找到最后一个元素

	cur.next = node
	node.pre = cur
	this.length++
}

// 修改
// 按照索引修改、按照数据修改
// 直接找到该数据所在结点，然后进行 cur.data 值度盖

func main() {
	a := CreateDL()

	a.Insert(1, 55)
	a.Travel()
	a.Insert(1, 666)
	a.Travel()
	a.Append(2333)
	a.Travel()
	a.Insert(2, 1000)
	a.Travel()
}

```









# 4、单向循环链表

* ### 与单向链表的区别



### 有头节点的

# 5、双向循环链表

* ### 与双向链表的区别































































































