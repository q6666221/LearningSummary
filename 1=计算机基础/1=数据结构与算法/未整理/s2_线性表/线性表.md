# 前言

* 数据结构每个人写出来的都不一样，只挑自己认为好的补充到自己笔记当中

# 线性表

*    线性存储结构 

*    将具有“一对一”关系的数据“线性”地存储到物理空间中 

*    线性表存储的数据，类型必须都一致，否则不行。 

    *   这个感觉有点儿不太对

*   零个或者多个数据元素的有限集合

    ```go
    1.它是个序列，元素之间有顺序
    	1.第一个元素无前驱
    	2.最后一个元素无后继
    	3.其他元素有且只有一个前驱和后继
    2.它是有限的。
    	1.元素的个数是有限的
    	2.无限的概念值只存在于数学的概念中
    ```

*   分类

    *   顺序存储结构
    *   链式存储结构
        * 非循环列表	：单向、双向  ：（单链表、双链表）
        * 循环列表        ：单向、双向

*   有关概念

    *   线性表数学表述

    *   

    *   非空链表中的每个数据元素都有一个确定的顺序

        *   数据元素：  数据中的每个个体  。a1,a2

        *   直接前驱元素 ：元素左边相邻的元素
        *   前驱元素        ： 元素左边的所有元素
        *   直接后继元素 ： 元素右边相邻的元素
        *   后继元素        ： 元素右边的所有元素
        *   首个数据元素：有且只有一个前驱元素
        *   最后的数据元素：有且只有一个后继元素
        *   数据 ai 的 i ：数据元素在线性表中的位序
        *   



## 1.链表基础

* 先看看指针的作用，

* 单向链表、单向循环链表
* 双向链表、双向循环链表

### 1.创建

   * 节点

     ```go
     //节点进行
     创建节点：CreateNode NewNode InitNode
     ```

     

   * 空列表

   * 创建提供初始元素序列

     ```go
     // 你可以不用进行初始化，因为 go 中默认的就各个类型的零值，这个结果就相当于初始化了
     创建使用的字符跟节点一样
     ```


 ### 2.查看

```go
 // 表的状态
非空表    空表	

// 操作
判空	:is_empty
遍历	：travel
查长	: getsize getlength length
查询  : search
```

*   判断
    *   判空 is empty
    *   判断是否为 头节点 is head
    *   判断是否为 尾节点 is tail
*   查询 
    *   头节点 get tail
    *   尾节点 get head
    *   中间某个节点 search
    *   获取下一个节点 get next
    *   获取上一个节点 get prev
    *   获取节点内的数据 

### 3.动态改变表

   ```go
 // 表的状态
非空表    空表	

// 位置 + 数据
中间位置	表头	表尾	指定索引

// 操作
添加   删除(remove)  修改  

// 
排序
   ```

*   添加
    *   因为涉及到空指针问题，所以这个最好分开来讨论
    *   位置
    
        *   头部 ：add
    
        *   尾部 : append  = 新增数据，添加数据，均尾部操作
    
        *   中间:   insert
            
            *   前插 ：inset prev
            *   后插： insert next
            *   中间的设置一些问题是可以兼容头部和尾部添加的
    *   结果的顺序
        *   保序、非保序 ： 【参看顺序表】
    
*   删除
    
    *   删除涉及三个节点：删除节点前面的、删除节点、删除节点以后的，
    
    *   没有节点
    *   只有一个节点
    *   其他

### 4.多表操作

   * 组合
     * 完全合并
     * 条件合并

### 5.其他需要整理的

```go
//回收链表到备用链表
//回收节点
```

### 6.注意

*   ```go
    单向链表不能自我删除，需要靠辅助节点，而双向链表可以自我删除。
    ```






## 2.顺序表、线性表对比

*   存储数据

    *   线性表：需预先申请一整块足够大的存储空间，然后将数据按照次序逐一存储，数据之间紧密贴合，不留一丝空隙，

    *   链表    ： 什么时候存储数据，什么时候才申请存储空间，数据之间的逻辑关系依靠每个数据元素携带的指针维持 

*   开辟空间的方式

    *   顺序表 
        *    "一次开辟，永久使用"，即存储数据之前先开辟好足够的存储空间，空间一旦开辟后期无法改变大小（使用动态数组的情况除外）。 
    *    链表 
        *    存储数据时一次只开辟存储一个节点的物理空间，如果后期需要还可以再申请。 
    *   注意
        *    若只从开辟空间方式的角度去考虑，当存储数据的个数无法提前确定，又或是物理空间使用紧张以致无法一次性申请到足够大小的空间时，使用链表更有助于问题的解决。 

*   空间利用率

    *    顺序表的空间利用率显然要比链表高 
    *    链表在存储数据时，每次只申请一个节点的空间，且空间的位置是随机的 。 会产生很多空间碎片，一定程序上造成了空间浪费。不仅如此，由于链表中每个数据元素都必须携带至少一个指针，因此，链表对所申请空间的利用率也没有顺序表高。 

*   解决问题

    *    涉及访问元素的操作，元素的插入、删除和移动操作极少； 

        *    顺序表

            ```go
            1. 顺序表中存储的元素可以使用数组下标直接访问，无需遍历整个表，因此使用顺序表访问元素的时间复杂度为 O(1)；
            2. 链表中访问数据元素，需要从表头依次遍历，直到找到指定节点，花费的时间复杂度为 O(n);
            ```

    *    涉及元素的插入、删除和移动，访问元素的需求很少 

        *    链表 

            ```go
            1. 链表中数据元素之间的逻辑关系靠的是节点之间的指针，当需要在链表中某处插入或删除节点时，只需改变相应节点的指针指向即可，无需大量移动元素，因此链表中插入、删除或移动数据所耗费的时间复杂度为 O(1)；
            2. 顺序表中，插入、删除和移动数据可能会牵涉到大量元素的整体移动，因此时间复杂度至少为 O(n);
            ```

    ## 3.存储结构&存取结构

    *    存储结构

        *    数据在内存中真实的存储状态 	
        *   分为两类
            *    顺序存储结构 ：顺序表
            *    链式存储结构 ：链式、栈、队列

    *   存取结构

        *    存取数据的方式 
        *   分类
            *    顺序存取结构 ：链式存储结构（）
            *    随机存取结构  ：顺序存储结构（有下标）

    *   实例

        *    线性表的 顺序存储结构 是 随机存取结构 

            ```go
            1. 是通过数组的下标可以随机访问到数据，进行存取数据
            ```

        *    线性表的 链式存储结构 是 顺序存取结构 

            ```go
            在链表中存或者取数据，就只能从链表头 Head 开始，逐个遍历链表中的每个元素，直至找到目标元素。也就是说，从链表中存和取数据，必须从遵循各个元素在链表中存储的逻辑顺序，无法随机存取。
            ```

            

## 注意

*    链表增删快，查询慢，数组查询快，增删慢 

     ```go
     头节点		尾结点
     nil		  nil		lenth
     
     // 使用的例子都是 有头节点 无为节点  以 nil 判断结尾的
     
     // 最好是有头节点 尾节点  计量用length ,这种最简单，为哈要用不好用的呢
     ```

     

