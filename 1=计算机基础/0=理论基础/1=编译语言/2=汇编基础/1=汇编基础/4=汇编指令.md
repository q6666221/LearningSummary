```go
汇编指令不区分大小写
```



## mov

```go
mov A B   // 将 B 的存入 A 中

	mov 寄存器，数据
	mov 寄存器，寄存器

	mov 寄存器，内存单元  // 搭配 ds
	mov 内存单元，寄存器  // 搭配 ds

	mov 段寄存器，寄存器  // ds
	// mov 寄存器，段寄存器   也是可以的


寄存器 ：用寄存器名来指明
内存单元 ： 需要用内存单元的地址来指明
	[...] 表示内存单元
	[0] 的 0 表示内存单元的偏移地址，段地址自动取 ds 中的数据

 
mov ax , 18    将 18 送入寄存器 ax     ax=18
mov al , bx   将 bx 的美容移动到 ax  的 地位
 // 这个要搭配 ds 寄存器使用
    mov [0] , al   // [0] 和 al 对应是 8 位
    move ax , [0]  // [0] 和 ax 对应是 16 位



add ax, 78   将寄存器 ax 中加上 18   ax = ax + 78

```

## add

```go
add A B   // A = A + B

	add 寄存器，数据
	add 寄存器，寄存器

	add 寄存器，内存单元
	add 内存单元，寄存器
```



## sub

```go
sub A B   // A = A - B

	sub 寄存器，数据
	sub 寄存器，寄存器

	sub 寄存器，内存单元
	sub 内存单元，寄存器
```



## mul  乘法

*   注意

    | 乘数     | 乘数                             | 乘积              |
    | -------- | -------------------------------- | ----------------- |
    | 8位(AL)  | 8位  ：(8位reg或内存 字节单元中) | AX                |
    | 16位(AX) | 16位 ：(16位reg或内存 字单元中)  | 高位(DX) 低位(AX) |

*   格式

    ```assembly
    mul reg
    mul 内存单元
    ; reg
    mov al , 100
    mov bl , 10
    mul bl
    	; 计算 100 * 10
    	
    ; 内存单元
    mul byte ptr ds:[0]
    	(ax) = (al) * ( (ds) * 16 + 0)
    mul word ptr [bx+si+0]
    	(ax) = (ax) * ((ds)*16 + (bx) + (si) + 0) 结果的低 16 位
    	(bx) = (ax) * ((ds)*16 + (bx) + (si) + 0) 结果的高 16 位	
    	
    ```

    

## div 除法

*   注意

    *   除数存放位置 ：reg 或者 一个内存单元中

    | 除数 | 被除数                         | 商   | 余数 |
    | ---- | ------------------------------ | ---- | ---- |
    | 8位  | 16位 ：AX                      | AL   | AH   |
    | 16位 | 32位 ：DX (高16位)、AX(低16位) | AX   | DX   |

*   格式

    ```assembly
    div reg
    div 内存单元
    
    ; 例子
    div byte ptr ds:[0]
    	含义 ： (al) = (ax) / ((ds)*16 + 0 ) 的商
    		   (ah) = (ax) / ((ds)*16 + 0 ) 的余数
    div word ptr es:[0]
    	含义 ： (ax) = [ (dx)*10000H + (ax)] / ((es)*16 + 0) 的商
    		   (dx) = [ (dx)*10000H + (ax)] / ((es)*16 + 0) 的余数
    	
    ```

    

## 栈指令

### push+pop

```go
// 8086CPU 的栈操作都是以 字 为单位进行的
// 栈顶到底 ：内存地址依次增大 ，
push
    push A 将 A 中的数据入栈
    push 寄存器
    push 段寄存器 
    push 内存地址 // 段地址在执行命令时，CPU 从 ds 中获取

push ax  // 将寄存求 ax 中的数据送入栈中
	1. sp = sp -2 （字操作，指向下一位）
	2. 将 ax 中的内容送入 SS:SP 中指向的内存单元处， SS:SP 此时指向新栈顶

//===================================================================================

pop
    pop A  出栈 ，栈中的元素放到寄存器 A 中
    push 寄存器
    push 段寄存器 
    push 内存地址

pop ax   // 从栈顶取出数据送入 ax
1. 将 SS:SP 指向的内存单元处的数据送入 ax 中
2. sp = sp + 2 （字操作，指向上一位）
	SS:SP 指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶
	出栈后的数据依然存在，只不过不在栈中
	执行新的 push 操作的时候，会覆盖掉原本的值


栈顶元素 ： SS:SP 任意时刻都指向栈顶元素

栈空 ： SS:SP 指向空间最高地址单元的下一个单元
非空 ： SS:SP 指向栈顶元素的低位
栈段地址   ：SS
栈偏移地址 ：SP
```

### call + ret  ?

*   ret

```assembly
; 用于栈中的指令 
ret  修改 IP 内容，实现近转移
retf 修改 IP 和 CS 的内容，从而实现远转移

ret   ;pop IP
	(IP) = ((ss)*16+(sp))
	(sp) = (sp) + 2

retf	; pop IP     pop CS
	(IP) = ((ss)*16+(sp))
	(sp) = (sp) + 2
    (CS) = ((ss)*16+(sp))
    (sp) = (sp) + 2
```

*   call

```assembly
call  ; 和 jmp 相似，但是不能实现短转移
	1.将当前的 IP 或者 IP+CS 压入栈
	2.转移
	
; 1. 根据位移进行转义
call 标号 (将当前的 IP 压栈后，转到标号处执行指令) ; push IP  jmp near ptr 标号
	; 对应的机器指令中没有转移目的地址，而是相对于当前IP的转移位移
	1. (sp) = (sp) - 2
	   ((ss) * 16 + (sp)) = (IP)
	2. (IP) = (IP) + 16 位位移
	
	1. 16 位位移 = 标号处的地址 - call 指令后的第一个字节的地址
    2. 16 位位移的范围为 -32768 ~ 32767 ，用补码表示
    3. 16 为位移由编译程序在编译时计算得出

;2. 转移的目的地址在指令中
call far ptr 标号  (实现段间转移) ; push cs 、push ip 、 jmp far ptr 标号
	1.  (sp) = (sp) - 2
		((ss)*16+(sp)) = (CS)
		(sp) = (sp) - 2
		((ss)*16+(sp)) = (IP)
	2.  (CS) = 标号所在的段的段地址
		(IP) = 标号在的断种的偏移地址
		
; 3. 转移地址在寄存器中
call 16位reg   ; push ip 、jmp 16位reg
	(sp) = (sp) - 2
	((ss)*16+(sp)) = (IP)
	(IP) = (16位reg)
	
; 4. 转移命令在内存中
call word ptr 内存单元地址 ; push IP 、 jmp word ptr 内存地址
call dword ptr 内存单元地址 ; push CS 、push IP 、 jmp dword ptr 内存地址
```

### pushf + popf

```assembly
; 为直接访问标志寄存器提供了一种方法
pushf	: 将标志寄存器的值	压栈
popf	：将标志寄存器的值	弹出数据
```





## inc

```assembly
inc bx ; bx = bx +1
```



## 逻辑指令 and - or

```assembly
and a ,b   (a = a and b)
	逻辑与指令，按位与运算
	将操作对象的相应位设置为 0 ， 其他位不变（b 是 0 的位置，a 对应的都是 0）

or a , b  (a = a or b)
	逻辑或指令，按位进行或运算
	将操作对象的相应位设置为 1 ，其他位置不变（b 是 1 的位置，a 对应的都是 1）
```



*   

## 转移指令

*   概念

    *   可以修改 IP 或者 同时修改 CS 和 IP 的指令
    *   概括就是：可以控制CPPU执行内存中某处代码的指令

*   分类

    *   转移行为

        ```assembly
        1. 段内转移
             只修改 IP  ：jump ax
        2. 段间转移 
        	同时修改 IP 和 CS  :jump 1000:0
        ```

        

    *   IP 修改范围

        ```assembly
        1. 短转移
        	IP 修改范围 -127 ~ 128
        2. 近转移 
        	IP 修改范围 -32768 ~ 32767
        ```

    *   功能

        *   无条件转移指令
        *   条件转移指令
        *   循环指令
        *   过程
        *   中断

### offset - 伪

```assembly
assume cs:codesg
codesg segment
	start : mov ax , offset start  ; 相当于 mov ax , 0
	s 	  : mov ax , offset s      ; 相当于 mov ax , 3
	
start : mov ax , offset start  ; 相当于 mov ax , 0
	offset start 取得标号 start 的偏移地址为 0 （start 标记的是第一条指令，偏移地址为 0）
s 	  : mov ax , offset s      ; 相当于 mov ax , 3	
	offset s   取得标号 s 的偏移地址为 3 （标记第二条指令，第一条指令长度为3个字节，则s的偏移地址为3）
```



### jmp

*   无条件转移指令，可只修改IP 或者同时修改CS和IP

*   给出的信息
    *   转移的目的地址
    *   转移的距离（段间转移、段内短转移、段内近转移）

*   根据位移转移 -- 相对于当前 IP 的转移位移

    ```assembly
    jmp short 标号（转到标号处执行指令）
    	段内短转移
    	标号 ： 是带妹妹段中的标号，指明了指令要转移的目的地，转移指令结束后，CS:IP 应该指向标号处的指令
    	CPU 在执行 jump 指令的时候并不需要转义的目的地址，
    	

    ; 实例
    assume cs:codesg
    codesg segment
    	start :mov ax,0
    		   jmp short s  ; 直接跳转到 s 所在的代码段，跳过 add  ax , 1
    		   add ax,1
    	s : inc ax
    codesg ends
    end start
    
    ; 原理
    
    jmp short 标号 功能为 ： (IP) = (IP) + 8
    
    1. 8 位位移 = 标号处的地址 - jmp 指令后的第一个字节的地址
    2. short 这里此处的位移为 8 位位移
    3. 8 位位移的范围为 -128~127 ，用补码表示
    4. 8 为位移由编译程序在编译时计算得出
    
    jmp near ptr 标号 功能为 ： (IP) = (IP) + 16
    
    1. 16 位位移 = 标号处的地址 - jmp 指令后的第一个字节的地址
    2. near ptr 这里此处的位移为 16 位位移,进行的是段内近转移
    3. 16 位位移的范围为 -32768 ~ 32767 ，用补码表示
    4. 16 为位移由编译程序在编译时计算得出
    
    ```
    
*   转移的目的地址

    ```assembly
    jmp far ptr 标号  功能 ： 实现的是段间转移，又称远转移
    	(CS) = 标号所在段的段地址
    	(IP) = 标号在段中的偏移地址
    	far ptr 指明指令用标号的段地址和偏移地址修改 CS 和 IP
    	
    ```

*   转移地址在寄存器

    ```assembly
    jmp 16位寄存器  
    	功能 (IP) = (16位寄存器)
    ```

*   转移地址在内存中

    ```assembly
    jmp word ptr 内存单元地址(段内转移)
    	功能 ：从内存单元地址处开始存一个字，是转移的目的偏移地址
    
    
    jmp dword ptr  内存单元地址(段间地址)
    	功能 ： 从内存单元地址开始从存放两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址
    		(cs) = (内存单元地址+2)
    		(IP) = (内存单元地址)
    ```

### jcxz - 位移

*   有条件转移指令

*   所有有条件转移指令都是短转移，在对应机器码中包含的是转移的位移，而不是目的地址

*   IP 修改范围是 -128 ~ 127

    ```assembly
    jcax 标号 （如果 (cx) = 0 , 转移到标号处执行
    	操作 ：
        	当 (cx) = 0 时， (IP) = (IP) + 8 位位移
        	当 (ca) ≠ 0 时，什么也不做，程序往下执行
    1. 8 位位移 = 标号处的地址 - jcax 指令后的第一个字节的地址
    2. 8 位位移的范围为 -128~127 ，用补码表示
    3. 8 为位移由编译程序在编译时计算得出
    
    ; C 语言描述
    if ((cx) == 0)) jmp short 标号
    ```

    

### loop

*   所有的循环指令都是短转移
*   在对应机器码中包含的是转移的位移，而不是目的地址
*   IP 修改范围是 -128 ~ 127

```assembly
loop 执行步骤
1. (cx) = (cx) - 1  ; CX 存放循环次数
2. 判断 cx 中的值，
	不为 0 则转至标号处执行程序
	是 0 ，则向下执行，什么也不做


	mov cx,11 
s : add ax,ax
	loop s

s: 标号，代表一个地址，该地址有一个指令，指令为 add ax,ax
```



### call + ret 

*   参看栈指令



### 检测比较结果的条件转移指令

*   概念

    ```go
    转移 ： 能够修改 IP
    条件 ： 它根据某种条件，决定是否修改 IP
    	大多数条件转移指令都检测标志位寄存器的相关标志位 ，然后跟据结果过决定是否修改 IP
    	通常都和 cmp 配合使用
    ```

*   无符号

    ```assembly
    ; 根据比较结果进行转义的条件转移指令
    指令			含义					相关标志位
    je			等于    则转移			 zf=1
    jne			不等于  则转移			zf=0
    jb			低于    则转移			 cf=1
    jnb			不低于   则转移			cf=0
    ja			高于	  则转移			 cf=0 zf=1
    jna			不高于  则转移			cf=1 zf=1
    
    j jmp
    e equal  ne : not equal
    b below  nb : not below
    a above  na : not above
    
    ; 例子
    cmp ah , bh
    je s
    s add ah , bh
    	; 如果(ah) = (bh) 则(ah)=(ah)+(bh)
    ```

    

    

## 标注位指令



### adc

*   进位加法指令，利用 CF 位上记录的进位制

    ```assembly
    ; 格式
    	adc 操作对象1 ，操作对象2
    ; 功能
    	操作对象1 = 操作对象1 + 操作对象2 + CF
    ; 例子
    	adc ax , bx == (ax) = (ax) + (bx) + CF
    ; 加法过程
	1. 低位相加
    	2. 高位相加再加上低位相加产生的进位值
    ```
    

### sbb

*   带借位减法指令，利用 CF 位上记录的借位值(已经借出)

    ```assembly
    ; 格式
    	sbb 操作对象1 ，操作对象2
    ; 功能
    	操作对象1 = 操作对象1 - 操作对象2 - CF
    ; 例子
    	abb ax , bx == (ax) = (ax) - (bx) - CF
    ; 加法过程
    	1. 低位相加
    	2. 高位相加再加上低位相加产生的进位值
    ```

### cmp

*   介绍

    *   比较指令，相当于减法指令，只是不保存结果
    *   该命令指令后，对标志位产生影响
    *   其他相关指令，通过是被被影响的寄存器来得知比较结果

*   格式

    ```assembly
    ; 格式
    	cmp 操作对象1 ， 操作对象2
    ; 功能
    	操作对象1 - 操作对象2 。但是不保存结果，仅仅根据结果对标致寄存器进行设置
    ; 例子
    无符号
    cmp ax , bx
    	(ax) = (bx)  zf=1
    	(ax) ≠ (bx)  zf=0
    	(ax) < (bx)  cf=1			; 产生借位
    	(ax) ≥ (bx)  cf=0			; 不必借位，
    	(ax) > (bx)  cf=0 且 zf=0	; 不必借位，结果又不为 0
    	(ax) ≤ (bx)  cf=1 且 zf=1	; 不必借位，结果可能为 0
    	
    有符号
    cmp ah , bh
    
    (ah) = (bh)  zf=1
    (ah) ≠ (bh)  zf=0
    (ah) < (bh)  sf=1 of=0 或者 sf=0 of=1
    	of=0 没有溢出，逻辑上真正结果的正负 = 实际结果的正负
    	sf=1 实际结果为负，所以逻辑上真正的结果为负
    	
    (ax) > (bx)  sf=1 of=1
    	of=1 有溢出，逻辑上真正结果的正负 ≠ 实际结果的正负
    	sf=1 实际结果为负
    	因为溢出导致实际结果为负，逻辑上真正的结果必然是正
    (ax) ≥ (bx)  sf=0  of=0	; 不必借位，结果又不为 0
    	of=0 没有溢出，逻辑上真正结果的正负 = 实际结果的正负
    	sf=0 实际结果为正，所以逻辑上真正的结果为负
    ```

    

### movsb + movsw + rep

*   都是穿传送的操作中的一个步骤

```assembly
movsb
; 格式	 
	movsb  
; 功能
	将 ds:si 指向内存单元中的字节送入 es:di 中，然后根据标志寄存器 df 的值，减 si 和 di 进行递减或者递增 1
	1. ((es)*16+(di)) = ((ds)*16+(si))
    2. 如果 df = 0 
    	(si) = (si) + 1
    	(di) = (di) + 1
       如果 df = 1
       	(si) = (si) - 1
       	(si) = (di) - 1
       	
movsw
; 功能
	将 ds:si 指向内存单元中的字节送入 es:di 中，然后根据标志寄存器 df 的值，减 si 和 di 进行递减或者递增 2
	

跟 rep 合用

rep movsb

等价于
    s  : movsb
        loop s
功能
	rep 根据 cx 的值，重复执行后面的串传送命令，
	每执行一次 movsb 指令 si 和 di 都会递增或者递减指向后一个单元或者前一个单元
	rep movsb 则可以循环实心 (cx) 个字符的传递
```

### cld + std

```assembly
cld
; 格式
	cld
 ; 功能
 	将标志寄存器的 df 位设置为 0
 
 std
 ; 格式
 	std
 ; 功能
 	将标志寄存器的 df 位设置为 1
```

### pushf + popf

```assembly
参见 栈指令
```



## init





































































































