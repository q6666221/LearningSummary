

## 基础原型模式

```go

type Dog struct {
	call string
}

// 添加克隆方法
func (d *Dog) clone() *Dog {
	dc := *d // 使用 *指针，直接获取了一个拷贝的值，然后将这个拷贝的值得指针返回
	return &dc
}

func main() {
	d1 := new(Dog)
	d1.call = "666"
	d2 := d1.clone()
	fmt.Println(d2.call)  // 666 实现复制
	d2.call = "233"
	fmt.Println(d1)	// &{666}
	fmt.Println(d2) // &{233}
}

```



## 带抽象接口

```go
// 实现该接口，即完成了原型模式的定义
type Cloneable interface {
    clone() Cloneable
}

type Dog struct{
    call string
}

// 这个地方如果使用 cloneable 换成 interface{}
// clone 的时候，可以使用断言  d2,ok := d1.clone().(*Dog)
func (d *Dog) clone() Cloneable {  
    res := *d
    return res   
}

func main(){
    d1 := new(Dog)
    d1.call = "666"
    
}
```

## 带原型管理器

*   需要创建不同类型的对象时，我们需要调用不同的对象来进行扩展
*   在原型模式的基础上增加了一个原型管理器 PrototypeManager 类,通过该管理器获取不同的类型原型

```go
// 用map保存多个不同的原型,通过传入不同的类型参数名，即可获取到不同的类型原型（cat或dog）

type Animal interface {
    Clone Animal
    Call() 
}

type Cat struct {
    call string
}

func (c *Cat) Call() {
    fmt.Println("c.call")
}

func (c *Cat) Clone() Animal {
    /*
    res := *c
    return res
    */
    
    newcat := new(Cat)
    new.call = c.call
    return newcat
}

type AnimalManager struct {
    AnimalMap map[string]Animal
}

// class 种类
func (a *AnimalManager) GetAnimal (class string) Animal {
    animal, ok := a.AnimalMap[class]
    if ok {
        return animal
    } else {
        fmt.Printf("所查询的 %s 不存在",class)
    }
    return nil
}

func (a *AnimalManager) SetAnimal (class string,animal Animal) {
    // 判断重复之类的，就不写了，这不是重点
    if a.AnimalMap == nil {
        a.AnimalMap = make(map[string]Animal)
    }
    a.Animal[class] = animl
}

func main(){
    // 创建实例原型
    cat1 := new(Cat)
    cat1.call = "喵喵喵"
    dog1 := new(Dog)
    dog1.call = "汪汪汪"
    
    // 设置原型管理器
    manager := new(AnimalManager)
    manager.SetAnimal("cat",cat1)
    manager.SetAnimal("dog",dog1)
    
    // 取出原型,取出来就可以进行 clone
    cat2,ok := manager.GetAnimal("cat").clone().(Animal)
    if !ok {
        fmt.Println("转换失败")
    }
    cat2.call() // 喵喵喵
    
    
    
}
```

